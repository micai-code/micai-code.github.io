<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java之HttpClient调用WebService接口发送短信实战源码]]></title>
    <url>%2F2020%2F10%2F29%2FJava%E4%B9%8BHttpClient%E8%B0%83%E7%94%A8WebService%E6%8E%A5%E5%8F%A3%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E5%AE%9E%E6%88%98%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[摘要Java之HttpClient调用WebService接口实战 一：接口文档 二：WSDL 三：HttpClient方法HttpClient方法一 HttpClient方法二 HttpClient方法三 HttpClient方法四 四：封装soapXml方法(核心方法) 五：调用WebService接口 六：调用结果 七：短信结果 完结以上就是Java之通过HttpClient方式调用WebService接口的完成流程]]></content>
      <categories>
        <category>WebService</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2 + MyBatis 实现动态传递表名称, 字段名称 查询数据]]></title>
    <url>%2F2020%2F10%2F23%2FSpring-Boot-2-MyBatis-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BC%A0%E9%80%92%E8%A1%A8%E5%90%8D%E7%A7%B0-%E5%AD%97%E6%AE%B5%E5%90%8D%E7%A7%B0-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[Spring Boot 2 + MyBatis 实现动态传递表名称, 字段名称 查询数据摘要：之前有个需求,需要动态查询某一个表的某些字段,看了下MyBatis的文档,它可以支持的,具体做法如下: 一:Controller层1234567891011121314151617181920212223242526272829303132333435363738package boss.portal.web.controller; import boss.base.web.controller.BaseController;import boss.base.web.support.ResponseModel;import boss.portal.web.service.CommonService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.List;import java.util.Map;/** * 描述： * &lt;p&gt; * Author: 赵新国 * Date: 2018/1/31 17:48 */@RestController@Api(value = "公共接口管理", description = "公共接口管理")@RequestMapping(value = "/common")public class CommonController extends BaseController &#123; @Autowired private CommonService commonService; @ApiOperation(value = "根据ID获取指定实体,字段对应的返回值", notes = "根据ID获取指定实体,字段对应的返回值") @RequestMapping(value = "/get", method = RequestMethod.GET) public ResponseModel get(@RequestParam(required = false) String ids, @RequestParam(required = false) String tableName, @RequestParam(required = false) String fields) &#123; List&lt;Map&lt;String, Object&gt;&gt; maps = commonService.get(ids, tableName, fields); return renderSuccess(maps); &#125; &#125; 二:Service层123456789101112131415161718192021222324package boss.portal.web.service; import boss.auth.user.provider.IUserProvider;import com.alibaba.boot.dubbo.annotation.DubboConsumer;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;/** * 描述： * &lt;p&gt; * Author: 赵新国 * Date: 2018/1/31 17:48 */@Componentpublic class CommonService &#123; @DubboConsumer(lazy = true) private IUserProvider userProvider; public List&lt;Map&lt;String,Object&gt;&gt; get(String ids, String tableName, String fields) &#123; List&lt;Map&lt;String, Object&gt;&gt; maps = userProvider.get(ids, tableName, fields); return maps; &#125;&#125; 三:Provider层12345678@Overridepublic List&lt;Map&lt;String, Object&gt;&gt; get(String ids, String tableName, String fields) &#123; List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.get(ids, tableName, fields); if (maps != null &amp;&amp; !maps.isEmpty()) &#123; return maps; &#125; return null;&#125; 四:Mapper层1List&lt;Map&lt;String,Object&gt;&gt; get(@Param("ids") String ids, @Param("tableName") String tableName, @Param("fields") String fields); 五:Mapper.xml1234&lt;!-- 根据指定ID获取指定数据表的指定字段的数据集 --&gt;&lt;select id="get" resultType="java.util.Map" statementType="STATEMENT" &gt; select $&#123;fields&#125; from $&#123;tableName&#125; where id in ( $&#123;ids&#125; )&lt;/select&gt; 六：附录最后说明一下,fields代表你要查询的字段,tableName代表你要查询的表名称,ids代表你要查询的id集合, 这样你就可以随意查询任何你想要的表和字段了,再也不用担心其他人让你加接口了! 七：结束语以上就是Spring Boot, MyBatis 实现动态传递表名称, 字段名称 查询数据的全部代码了，如有问题，请加群讨论：715224124]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven之自定义archetype生成多模块结构的基础项目骨架（二）]]></title>
    <url>%2F2020%2F10%2F23%2FMaven%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89archetype%E7%94%9F%E6%88%90%E5%A4%9A%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E9%AA%A8%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一：项目骨架介绍该项目骨架集成了Spring，SpringMVC，MyBatis，jsp，jquery，bootstrap等 二：项目骨架使用介绍1.首先下载该项目到你的本地工程 2.通过dos窗口进入到该工程的pom.xml所在目录 3.搭建nexus私服 4.配置发布到私服的用户，主要是maven的settings.xml，如下 releases admin admin123 snapshots admin admin123 5.执行mvn clean install命令 6.执行mvn deploy命令 7.登录nexus可以查看到你刚才发布的archetype包 三：在eclipse或者sts里面配置你刚才发布到私服的自定义archetype1.打开你的开发工具，eclipse或者sts，我这里是sts 2.选择Window-&gt;Preferences-&gt;Maven-&gt;Archetypes 3.点击Add Remote Catalog，输入你的nexus私服中archetype的地址，我这里是 http://127.0.0.1:8081/nexus/content/groups/public/archetype-catalog.xml 输入Description，随便输入都可以，我这里是micaicms-web-modules-archetype 4.点击Ok，点击Apply 5.重新启动你的开发工具eclipse或者sts 四：使用自定义的archetype生成自定义的项目骨架1.选择New-&gt;Maven Project-&gt;Next 2.选择你刚才配置好的那个archetype 3.输入对应的groupId，artifactId，package，点击Finish就会生成四个工程，一个父工程，三个子工程，这样通过自定义的archetype生成多模块基础框架就完成了 ，接下来你可以很好的在此基础上写自己的代码了 五：下载地址https://github.com/sxdtzhaoxinguo/micaicms-web-modules-archetype]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven之自定义archetype创建自定义模板项目骨架（一）]]></title>
    <url>%2F2020%2F10%2F23%2FMaven%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89archetype%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE%E9%AA%A8%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[描述：通过maven的自定义archetype创建自定义的项目模板骨架1.下载项目到你的本地workspace2.进入到你该项目的根目录(也就是pom.xml所在的目录)3.执行命令把该项目安装到你的本地仓库 mvn clean install4.执行命令更新你的本地仓库的索引 mvn archetype:update-local-catalog5.再次回到你的workspace工程目录，执行命令选择本地仓库的archetype创建项目 mvn archetype:generate -DarchetypeCatalog=local6.选择你的archetype的编号，然后根据提示输入你自己的groupId，artifactId，packaging，version等等7.导入创建成功的项目到eclipse，就可以使用该项目了8.下载地址https://github.com/sxdtzhaoxinguo/micaicms-web-archetype 9.博客地址https://blog.csdn.net/sxdtzhaoxinguo/article/details/46895013]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+Hibernate+SpringMVC+MySql实现多数据源]]></title>
    <url>%2F2020%2F10%2F23%2FSpring-Hibernate-SpringMVC-MySql%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Spring+Hibernate+SpringMVC+MySql实现多数据源1.下载下项目源代码，导入工程目录下2.项目要求开发环境： jdk 1.6+ tomcat 6.0+ mysql 5.0+ maven 3.23.导入后，先根据数据库配置文件，新建两个数据库dataSource1，dataSource24.选择项目的pom.xml，运行Maven test即可,顺利的话，会在控制台和target目录下看到执行测试的内容！5.下载地址：https://gitee.com/micai-code/SpringTwoDataSource.git]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring MVC</category>
        <category>Hibernate</category>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring，SpringMVC，MyBatis，bootstrap，jquery，jstl等集成的基础开发框架！]]></title>
    <url>%2F2020%2F10%2F23%2FSpring%EF%BC%8CSpringMVC%EF%BC%8CMyBatis%EF%BC%8Cbootstrap%EF%BC%8Cjquery%EF%BC%8Cjstl%E7%AD%89%E9%9B%86%E6%88%90%E7%9A%84%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%EF%BC%81%2F</url>
    <content type="text"><![CDATA[Spring，SpringMVC，MyBatis，bootstrap，jquery，jstl等集成的基础开发框架！项目介绍：1.软件架构组成：Maven Spring SpringMVC MyBatis jquery bootstrap jsp 2.软件集成依赖：Spring SpringMVC MyBatis Log4j jstl checkstyle findbugs 3.该项目中继承的父项目请看： https://github.com/sxdtzhaoxinguo/micaicms-pom4.下载地址：https://gitee.com/micai-code/micaicms-ssmb.git]]></content>
      <categories>
        <category>Spring MVC</category>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+Quartz集成实现的定时任务调度器，支持集群环境下的定时任务调用！]]></title>
    <url>%2F2020%2F10%2F23%2FSpring-Quartz%E9%9B%86%E6%88%90%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%8C%E6%94%AF%E6%8C%81%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8%EF%BC%81%2F</url>
    <content type="text"><![CDATA[Spring+Quartz集成实现的定时任务调度器，支持集群环境下的定时任务调用！项目整体介绍：Spring+Quartz集成实现的定时任务调度器，支持集群环境下的定时任务调用！ 项目开发环境：jdk1.7+，tomcat7.0+，sql server 2000+，mysql 5.6 项目数据库支持：项目支持MySQL,SqlServer数据库，Oracle我这里没试，有兴趣的朋友可以自己做下，其实就是sql脚本不一样，具体的sql脚本可以下载quartz官方文档查看，里面有 支持各种数据库的sql脚本 项目部署步骤：MySQL版本部署步骤：1.首先根据jdbc.properties文件里面的配置新建对应的数据库 2.执行db文件夹下的sql文件，先执行mysql_db.sql文件，再执行init_db.sql文件 3.部署到tomcat即可查看定时任务的调度情况 SqlServer版本部署步骤：1.首先根据jdbc.properties文件里面的配置新建对应的数据库 2.执行db文件夹下的sql文件，先执行sqlserver_db.sql文件，再执行init_db.sql文件 3.部署到tomcat即可查看定时任务的调度情况 下载地址：https://gitee.com/micai-code/quartzService.git]]></content>
      <categories>
        <category>Spring</category>
        <category>Quartz</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot，Dubbo，Zookeeper、MySql，Swagger2组成搭建的分布式基础框架]]></title>
    <url>%2F2020%2F10%2F23%2FSpring-Boot%EF%BC%8CDubbo%EF%BC%8CZookeeper%E3%80%81MySql%EF%BC%8CSwagger2%E7%BB%84%E6%88%90%E6%90%AD%E5%BB%BA%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[由Spring Boot，MyBatis，Dubbo，Zookeeper，MongoDB、RabbitMQ、Redis、MySql，Swagger2组成搭建的分布式基础框架！项目结构说明micai-boss —–micai-base —–&gt;基础模块 —–micai-doc —–&gt;数据库脚本和文档 —–micai-mongodb —–&gt;MongoDB服务插件 —–micai-order —–&gt;订单模块 —–micai-rabbitmq —–&gt;RabbitMQ服务插件 —–micai-redis —–&gt;Redis服务插件 —–micai-sms —–&gt;短信服务插件 —–micai-thrid —–&gt;Dubbo服务插件 —–micai-user —–&gt;用户服务 —–micai-utils —–&gt;工具类模块 —–micai-weixin —–&gt;微信API服务模块 项目启动前准备1.安装MySql服务 2.安装Zookeeper服务 3.安装Redis服务 4.安装RabbitMQ服务 5.安装MongoDB服务 项目启动步骤1.首先从git仓库下载项目到本地工程目录下 git clone https://gitee.com/micai/micai-boss.git 2.进入该项目的根目录下，通过命令的方式在本地编译项目 mvn clean compile -Dmaven.test.skip=true 3.编译成功后，导入IDEA工具中 4.分别启动对应的Dubbo服务即可，这里一共有如下几个服务: 4.1.micai-user-provider，micai-user-consumer，micai-weixin-impl，micai-sms-queue-impl，micai-sms-service-impl，micai-order-consumer 4.2.启动其中的两个服务，其他的都是类似的启动方法，打开micai-user-provider，找到UserProviderApplication类启动即可 4.3.当然启动Dubbo服务之前，一定记得先修改每个项目对应的配置文件，所有项目的配置文件都在resources目录下，读者可以根据自己实际情况修改即可 建议及改进 若您有任何建议，可以通过1）加入qq群715224124向群主提出，或2）发送邮件至827358369@qq.com向我反馈。本人承诺，任何建议都将会被认真考虑，优秀的建议将会被采用，但不保证一定会在当前版本中实现。 下载地址：https://gitee.com/micai-code/micai-boss.git]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Dubbo</category>
        <category>Zookeeper</category>
        <category>MySql</category>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Dubbo</tag>
        <tag>Zookeeper</tag>
        <tag>MySql</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个Nginx部署多个vue前端项目总结]]></title>
    <url>%2F2020%2F10%2F23%2F%E4%B8%80%E4%B8%AANginx%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AAvue%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[摘要：近来接手了一个二次开发的前后端分离模式的项目，其中在前端项目的部署上需要让2个前端项目都部署到一个IP地址和端口下，那么我们这里就要用到Nginx了，接下来我们看看如何在一个Nginx下部署2个前端项目的 编译打包2个前端项目执行如下命令执行对前端工程的打包，以生成静态文件，如下：1npm run build 把打包生成的静态文件上传到Linux服务器的指定目录，我这里是：/usr/local/lawyer_wsla/frontend/dist 同上，把另一个前端工程也执行打包命令，以生成静态文件，如下：把打包生成的静态文件上传到Linux服务器的指定目录，我这里是：/usr/local/lawyer_wsla/frontend/zjwsla 配置Nginx.conf文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#user nobody;user root;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /usr/local/lawyer_wsla/frontend/dist; try_files $uri $uri/ @router; index index.html index.htm; &#125; location /zjwsla &#123; alias /usr/local/lawyer_wsla/frontend/zjwsla; try_files $uri $uri/ /zjwsla/index.html; index index.html index.htm; &#125; location @router &#123; rewrite ^.*$ /index.html last; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 重启Nginx服务123cd /usr/local/nginx/sbin./nginx -s reload 访问项目 遇到的问题暂无]]></content>
      <categories>
        <category>Nginx</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 文件上传 源代码]]></title>
    <url>%2F2020%2F10%2F23%2FSpring-MVC-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E6%BA%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[摘要：Spring MVC实现文件上传： 代码截图如下： UploadController.java:12345678910111213141516171819202122232425262728package cn.csdn.controller; import java.io.File;import javax.servlet.http.HttpServletRequest;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile; @Controllerpublic class UploadController &#123; @RequestMapping(value="/upload.do") public String upload( @RequestParam(value = "file", required = false) MultipartFile file, HttpServletRequest request, ModelMap modelMap) throws Exception&#123; String path = request.getSession().getServletContext().getRealPath("upload"); String fileName = file.getOriginalFilename(); File targeFile = new File(path,fileName); if(!targeFile.exists())&#123; targeFile.mkdirs(); &#125; file.transferTo(targeFile); modelMap.addAttribute("fileUrl", request.getContextPath()+"/upload/"+fileName); return "result"; &#125;&#125; applicationContext.xml:1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd" default-lazy-init="true"&gt; &lt;!-- 启动Spring MVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter" lazy-init="false"/&gt; &lt;!-- 另外最好还要加入DefaultAnnotationHandlerMapping，不然会被 XML或其它的映射覆盖！ --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"/&gt; &lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/jsp/" p:suffix=".jsp"/&gt; &lt;!-- 支持上传文件 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="1048576"/&gt;&lt;!-- 设置上传文件的最大尺寸为1MB --&gt; &lt;/bean&gt; &lt;!-- SpringMVC在超出上传文件限制时，会抛出org.springframework.web.multipart.MaxUploadSizeExceededException --&gt; &lt;bean id="exceptionResolver" class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;!-- 遇到MaxUploadSizeExceededException异常时，自动跳转到/WEB-INF/jsp/error_fileupload.jsp页面 --&gt; &lt;prop key="org.springframework.web.multipart.MaxUploadSizeExceededException"&gt;error_fileupload&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; codeifAction.xml:123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd" default-lazy-init="true"&gt; &lt;bean id="uploadController" class="cn.csdn.controller.UploadController" /&gt; &lt;/beans&gt; index.jsp:1234567891011121314151617181920212223242526&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;title&gt;上传图片&lt;/title&gt;&lt;meta http-equiv="pragma" content="no-cache"&gt;&lt;meta http-equiv="cache-control" content="no-cache"&gt;&lt;meta http-equiv="expires" content="0"&gt;&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;&lt;meta http-equiv="description" content="This is my page"&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="upload.do" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"/&gt; &lt;input type="submit" value="上传"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; result.jsp:1234567891011121314151617181920212223&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;title&gt;上传结果&lt;/title&gt;&lt;meta http-equiv="pragma" content="no-cache"&gt;&lt;meta http-equiv="cache-control" content="no-cache"&gt;&lt;meta http-equiv="expires" content="0"&gt;&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;&lt;meta http-equiv="description" content="This is my page"&gt;&lt;/head&gt;&lt;body&gt; &lt;img alt="#" src="$&#123;fileUrl&#125;" style="width: 200px;height: 200px;"&gt;&lt;/body&gt;&lt;/html&gt; error_fileupload.jsp:12345678910111213141516171819202122232425262728&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'error_fileupload.jsp' starting page&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt; &lt;/head&gt; &lt;body&gt; 文件太大&lt;a href="history.go(-1)"&gt;返回&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 项目运行截图： 下载地址：http://pan.baidu.com/s/1qWNMxcS]]></content>
      <categories>
        <category>Spring MVC</category>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下安装 jdk-7u75-linux-x64.gz，jdk1.7.0_75，jdk1.7步骤]]></title>
    <url>%2F2020%2F10%2F23%2FLinux-%E4%B8%8B%E5%AE%89%E8%A3%85-jdk-7u75-linux-x64-gz%EF%BC%8Cjdk1-7-0-75%EF%BC%8Cjdk1-7%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[摘要近来又用到了Linux系统，所以就又新装了一个虚拟机和CentOS6.4来用，搞开发的程序猿们可能都知道，在现在的很多企业中，生产环境大多都是Linux服务器，并且用的比较多的大都是CentOS，Red hat系列的Linux系统环境，下面我就以我当前安装的CentOS 6.4来说明一下在该环境下安装Jdk 1.7.0_75版本的操作过程吧，如下所述： 下载JDK首先下载对应CentOS版本的jdk：这里我下载的是jdk-7u75-linux-x64.tar.gz，下载地址为：http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html 上传JDK下载该jdk到本地，并上传到你的CentOS 6.4系统的opt临时目录下。 检测JDK在安装自己下载的jdk之前，要先看看新安装的CentOS6.4系统自带的jdk版本，如果存在最好是卸载掉，然后再安装自己下载的jdk版本，如何卸载linux系统自带的jdk网上有很多例子，相信大家都会操作。 安装JDK新建一个jdk的安装目录，我这里是在/usr/local/下新建了java目录，命令:mkdir /usr/local/java ，再把 jdk-7u75-linux-x64.tar.gz压缩包从opt目录下复制到/usr/local/java目录下，命令如下： 1cp jdk-7u75-linux-x64.tar.gz /usr/local/java 解压缩JDK解压缩刚才下载的： jdk-7u75-linux-x64.tar.gz包，命令如下： 1tar xvf jdk-7u75-linux-x64.tar.gz 配置JDK环境变量解压完成后，进入到： 123[root@localhost~]# cd /etc[root@localhost etc]# vi profile 在profile文件的末尾加入如下命令： 1234export JAVA_HOME=/usr/local/java/jdk1.7.0_75export JRE_HOME=/usr/local/java/jdk1.7.0_75/jreexport PATH=$PATH:/usr/local/java/jdk1.7.0_75/binexport CLASSPATH=./:/usr/local/java/jdk1.7.0_75/lib:/usr/local/java/jdk1.7.0_75/jre/lib 输入:wq保存并退出，然后再重启CentOS 6.4系统。 验证JDK是否安装成功重新启动系统后，输入：java -version，如果看到如下截图说明你的jdk已经安装成功了。 常见问题就是修改profile文件，主要是权限不够。 可以先ls -l /etc/profile ，看一下权限，应该是644，然后执行chmod 666 profile，改了权限之后，可以把那些jdk的信息填到profile的最后面，执行:wq保存退出，重启就可以看到版本号了。]]></content>
      <categories>
        <category>Linux</category>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 从入门到精通]]></title>
    <url>%2F2020%2F10%2F23%2Fgit-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[摘要：git 操作指南 安装git下载 git OSX版下载 git Windows版下载 git Linux版 创建新仓库创建新文件夹，打开，然后执行 1git int 以创建新的git仓库。 检出仓库执行如下命令以创建一个本地仓库的克隆版本： 1git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： 1git clone username@host:/path/to/repository 工作流你的本地仓库由git维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是缓存区(Index)，它像个缓存区域，临时报错你的改动；最后是HEAD，指向你最近一次提交后的结果。 添加与提交你可以计划改动(把它们添加到缓存区)，使用如下名称： 12git add &lt;filename&gt;git add * 这是git基本工作流程的第一步；使用如下命令以实际提交改动： 1git commit -m &quot;代码提交信息&quot; 现在，你的改动已经提交到了HEAD，但是还没到你的远端仓库。 推送改动你的改动现在已经在本地仓库的HEAD中了。执行如下命令以将这些改动提交到远端仓库： 1git push origin master 可以把master换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加： 1git remote add origin &lt;server&gt; 如此你就能够将你的改动推送到所添加的服务器上去了。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“feature_x”的分支，并切换过去： 1git checkout -b feature_x 切换回主分支： 1git checkout master 再把新建的分支删掉： 1git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的： 1git push origin &lt;branch&gt; 更新与合并要更新你的本地仓库至最新改动，执行： 1git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行： 1git merge &lt;branch&gt; 两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 了。改完之后，你需要执行如下命令以将它们标记为合并成功： 1git add &lt;filename&gt; 在合并改动之前，也可以使用如下命令查看： 1git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签： 1git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID： 1git log 你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。 替换本地改动假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动： 1git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。 假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它： 123git fetch origingit reset --hard origin/master 有用的贴士内建的图形化 git： 1gitk 彩色的 git 输出： 1git config color.ui true 显示历史记录时，只显示一行注释信息： 1git config format.pretty oneline 交互地添加文件至缓存区： 1git add -i 链接与资源图形化界面GitX (L) (OSX, open source)Tower (OSX)Source Tree (OSX, free)GitHub for Mac (OSX, free)GitBox (OSX) 指南与手册Git 社区参考书专业 Git如 git 思考GitHub 帮助图形化的 Git 指南一则]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Mongodb Configuration Remove _class]]></title>
    <url>%2F2020%2F10%2F23%2FSpring-Boot-Mongodb-Configuration-Remove-class%2F</url>
    <content type="text"><![CDATA[摘要在使用Spring Boot整合Mongodb的过程中，在做insert对象的时候，在Collection中会出现一个_class字段属性，出现这个问题的原因是在调用mongoTemplate的insert方法时, spring-data-mongodb的TypeConverter会自动给document添加一个_class属性, 值是你保存的类名. 这种设计并没有什么坏处. spring-data-mongodb是为了在把document转换成Java对象时能够转换到具体的子类. 但有时候我们并不希望出现这个字段, 主要是看上去会比较”烦”. 可以通过设置MappingMongoConverter的MongoTypeMapper来解决这个问题。 解决方案在Spring Boot的启动类里面加入下面的代码即可 1234567891011121314151617181920212223242526272829303132333435package com.micai.springboot; import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.data.mongodb.MongoDbFactory;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.convert.DefaultDbRefResolver;import org.springframework.data.mongodb.core.convert.DefaultMongoTypeMapper;import org.springframework.data.mongodb.core.convert.MappingMongoConverter;import org.springframework.data.mongodb.core.mapping.MongoMappingContext; /** * Spring Boot应用启动类 * * @author 赵新国 on 2017/8/21. *///@EnableScheduling // 定时任务注解@SpringBootApplicationpublic class Application &#123; public static void main(String [] args)&#123; SpringApplication.run(Application.class,args); &#125; //mongodb entity remove _class @Bean public MongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory, MongoMappingContext context) &#123; MappingMongoConverter converter = new MappingMongoConverter(new DefaultDbRefResolver(mongoDbFactory), context); converter.setTypeMapper(new DefaultMongoTypeMapper(null)); MongoTemplate mongoTemplate = new MongoTemplate(mongoDbFactory, converter); return mongoTemplate; &#125; &#125;]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Mongodb</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot+Spring Security+JWT 实现 RESTful Api 认证（二）]]></title>
    <url>%2F2020%2F10%2F23%2FSpring-Boot-Spring-Security-JWT-%E5%AE%9E%E7%8E%B0-RESTful-Api-%E8%AE%A4%E8%AF%81%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring Boot+Spring Security+JWT 实现 RESTful Api 认证（二）摘要上一篇https://javaymw.com/post/59我们已经实现了基本的登录和token认证接口，但是这里有个问题，对于那些活跃用户来说如果token的过期时间设置的太短，那么就会使用户频繁的登录，这样用户体验不好，所以我们需要根据一种机制来判断什么时候应该主动刷新token，并且对于活跃用户来说应该是无感知的才行，那么我这里提供一种思路，暂且叫它2倍时间机制，那么怎么理解呢，请看下图： 代码 效果 结束语以上就是对JWT的刷新方案的实现，欢迎各位客官交流。]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Spring Security</category>
        <category>JWT</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot+Spring Security+JWT 实现 RESTful Api 认证（一）]]></title>
    <url>%2F2020%2F10%2F23%2FSpring-Boot-Spring-Security-JWT-%E5%AE%9E%E7%8E%B0-RESTful-Api-%E8%AE%A4%E8%AF%81%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[标题 Spring Boot+Spring Security+JWT 实现 RESTful Api 认证（一） 技术Spring Boot 2、Spring Security 5、JWT 运行环境IDEA+JDK8.0+MySQL5.0+ 简述Spring Boot 2 + Spring Security 5 + JWT 实现给RestApi增加认证控制 测试流程下面对我们的程序进行简单的验证1.请求获取用户列表接口:http://localhost:8080/users/userList接口，会收到401错误{ “timestamp”: 1567564486909, “status”: 401, “error”: “Unauthorized”, “message”: “Full authentication is required to access this resource”, “path”: “/users/userList”}curl http://localhost:8080/users/userList原因就是因为这个url没有授权,所以返回401 2.注册一个新用户curl -H “Content-Type: application/json” -X POST -d ‘{ “username”: “admin”, “password”: “password”}’ http://localhost:8080/users/signup 3.登录，会返回token，在http header中，Authorization: Bearer 后面的部分就是tokencurl -i -H “Content-Type: application/json” -X POST -d ‘{ “username”: “admin”, “password”: “password”}’ http://localhost:8080/login温馨提醒:这里的login方法是spring specurity框架提供的默认登录url 4.用登录成功后拿到的token再次请求/users/userList接口 4.1将请求中的XXXXXX替换成拿到的token 4.2这次可以成功调用接口了curl -H “Content-Type: application/json”-H “Authorization: Bearer XXXXXX”“http://localhost:8080/users/userList&quot; 5.设置了1分钟后Token过期，如果1分钟后再次请求/users/userList接口返回Token过期的异常提示如下图: 6.集成Swagger-ui，方便前后端分离开发，默认访问地址：http://localhost:8080/swagger-ui.html 温馨提示：这里的登录接口还是使用的默认地址，如果你的token过期了，需要你重新登录生成新的token. 下载地址https://gitee.com/micai-code/springboot-springsecurity-jwt-demo.git 结束语在使用的过程中，如有问题，可以添加真正讨论技术的QQ交流群，QQ群号为：715224124]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Spring Security</category>
        <category>JWT</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2 + Spring Security5 资源菜单按钮动态显示(7)]]></title>
    <url>%2F2020%2F06%2F07%2FSpring-Boot2-Spring-Security5-%E8%B5%84%E6%BA%90%E8%8F%9C%E5%8D%95%E6%8C%89%E9%92%AE%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA-7%2F</url>
    <content type="text"><![CDATA[前言上篇文章介绍了动态用户角色资源的权限管理，在结尾，也提到了个比较实际的问题 一般系统是不会让用户去点击了菜单才发现没有权限访问，而是针对不同的用户，动态显示不同的菜单 简单介绍那么怎么实现呢，通过Spring Securiyt的标签和后台动态标签验证就可以解决 那么，要想引用Spring Security标签，那么就要引入相应的标签库，因为小编这里用的前端模板是Thymeleaf，所以引入标签库如下： 1234&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt; 注意，因为我这里使用的是 Spring Security5 的版本，所以对应也是 thymeleaf-extras-springsecurity5 如果是 Spring Security4 的话对应就是 thymeleaf-extras-springsecurit4 然后每个页面只需要在html头部引入 xmlns:sec=“http://www.thymeleaf.org/extras/spring-security” 即可使用 Spring Security 标签库 实现这里基本介绍就介绍完了，下面开始说下怎么实现的动态显示菜单的问题 在需要动态显示的菜单上，加上 &lt;标签 sec:authorize=“hasAuthority(‘key’)”&gt; key则为资源表中的资源标识字段 那我们看看接上篇文章的代码，现在我想给我的菜单1、菜单2、菜单3动态显示，那么实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;index页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index页&lt;br/&gt;&lt;br/&gt;&lt;span sec:authorize="hasAuthority('menu1')"&gt; &lt;button id="menu1Btn" type="button" onclick="sendAjax('/menu1')"&gt;菜单1&lt;/button&gt;&lt;/span&gt;&lt;span sec:authorize="hasAuthority('menu2')"&gt; &lt;button id="menu2Btn" type="button" onclick="sendAjax('/menu2')"&gt;菜单2&lt;/button&gt;&lt;/span&gt;&lt;span sec:authorize="hasAuthority('menu3')"&gt; &lt;button id="menu3Btn" type="button" onclick="sendAjax('/menu3')"&gt;菜单3&lt;/button&gt;&lt;/span&gt;&lt;script src="http://libs.baidu.com/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function sendAjax(url) &#123; $.ajax(&#123; type: "GET", url: url, dataType: "text", success: function (data) &#123; console.log(data); &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 那么到这里我们就算完成了，我们看看效果 这里我们先用admin管理员角色登录，首页如下： 然后，再用teacher教师角色登录，首页如下： 最后，再用student学生角色登录，首页如下： 可以看到，对应不同的权限，显示不同的资源按钮 结束语那么基本代码和效果也演示完毕了 源码获取方式加加入QQ交流群(715224124)，进群找群主要源码，如果有问题，可以提出疑问，群主会尽量帮助解决~ 希望能帮助到大家，如果有不好或者错误的地方希望能多多提出，谢谢大家~]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2 + Spring Security5 动态用户角色资源的权限管理(6)]]></title>
    <url>%2F2020%2F06%2F07%2FSpring-Boot2-Spring-Security5-%E5%8A%A8%E6%80%81%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E8%B5%84%E6%BA%90%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-6%2F</url>
    <content type="text"><![CDATA[前言上篇文章介绍了Spring Boot Security基于Redis的Spring Session管理 本篇文章，可以说比较核心、实用的功能，动态用户角色资源管理(RBAC)，可能篇幅会比较长，废话不多说，马上进入正题 简单介绍相信每个正规的系统，都会对系统安全和访问权限有严格的控制。简单的一句话总结，就是对的人访问对的资源，这里可能会比较抽象，博主给大家举个例子就懂了： 现在假设有个系统，里面有菜单A、菜单B和菜单C客户有这么个需求，就是对于管理员来说，可以访问所有资源菜单，对于普通用户来说，只能访问菜单A和菜单B，如图： 相信这个也是广大系统都有的最基础的需求，那么在系统中的表现，就是用户登录了系统后，如果是普通用户的话，前端只显示菜单A和菜单B，其他途径访问(直接输入URL)菜单C会被提示无权限，而管理员则显示所有菜单 那么怎么实现呢，小编这里就是基于RBAC模型去实现的，简单来说就是： 举个例子： 用户就是登录系统的用户，像张三、李四、小王这样的具体登陆用户 角色就是假如张三是教师、李四是学生，那么教师和学生角色，也可能可以分得更细，这个根据需求来定义 资源就是访问系统的资源，如查询学生信息、编辑学生信息等等之类 用户和资源是没有直接关联的，用户是通过关联角色，角色再关联资源这种间接的方式去判断自己的资源权限。这样做的好处就是可以更简单直观的去管理用户资源间的关联，不需要说每创建一个用户，就去再重新分配资源这么繁琐，减少数据库冗余设计 数据库设计数据库表的设计如图： 这里有几点要说明下： 一般 用户 与 角色 是一对一或者一对多的关系，我这里为了方便所以选择一对一的关系 角色 与 资源 是多对多的关系，所以需要中间表 sys_role_resource 存储中间的联系 实体代码如下： Role.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-07 11:38 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.sys.entity;import org.springframework.security.core.GrantedAuthority;import javax.annotation.Resource;import javax.persistence.*;import java.util.Set;/** * @description: 角色实体类 * @author zhaoxinguo * @date 2020/6/7 11:38 */@Entity@Table(name = "sys_role")public class Role implements GrantedAuthority &#123; //id @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column protected Integer id; //角色标识 @Column private String roleKey; //角色名称 @Column private String roleName; //角色拥有的资源(多对多) @ManyToMany(targetEntity = Resource.class, fetch = FetchType.EAGER) @JoinTable( name = "sys_role_resource", joinColumns = &#123; @JoinColumn(name = "role_id", referencedColumnName = "id", nullable = false) &#125;, inverseJoinColumns = &#123; @JoinColumn(name = "resource_id", referencedColumnName = "id", nullable = false) &#125;) private Set&lt;Resource&gt; resources; @Override public String getAuthority() &#123; return roleKey; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getRoleKey() &#123; return roleKey; &#125; public void setRoleKey(String roleKey) &#123; this.roleKey = roleKey; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public Set&lt;Resource&gt; getResources() &#123; return resources; &#125; public void setResources(Set&lt;Resource&gt; resources) &#123; this.resources = resources; &#125;&#125; 这里要说明下，GrantedAuthority 接口中的getAuthorities()方法返回的当前用户对象拥有的权限，简单的说就是该用户的角色信息，所以这里我角色标识roleKey表示 Resource.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-07 11:42 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.sys.entity;import javax.persistence.*;import java.io.Serializable;/** * @description: 资源实体类 * @author zhaoxinguo * @date 2020/6/7 11:42 */@Entity@Table(name = "sys_resource")public class Resource implements Serializable &#123; //id @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column protected Integer id; //资源名称 @Column(nullable = false) private String resourceName; //资源标识 @Column(nullable = false) private String resourceKey; //资源url @Column(nullable = false) private String url; /** * 资源类型 * 0:菜单 * 1:按钮 */ @Column(nullable = false) private Integer type; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getResourceName() &#123; return resourceName; &#125; public void setResourceName(String resourceName) &#123; this.resourceName = resourceName; &#125; public String getResourceKey() &#123; return resourceKey; &#125; public void setResourceKey(String resourceKey) &#123; this.resourceKey = resourceKey; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public Integer getType() &#123; return type; &#125; public void setType(Integer type) &#123; this.type = type; &#125;&#125; 相信这些代码大家都看得明白，下面开始进入核心部分 实现在这里，博主介绍下怎么在Spring Security中实现资源管理功能，也就是针对不同的用户角色，动态的判断是否能访问相应的资源菜单 先看看项目结构图： 首先，我们需要在自定义登录认证那里，设置权限信息： LoginValidateAuthenticationProvider.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 21:59 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.core;import com.javaymw.demo.sys.entity.User;import com.javaymw.demo.sys.service.UserService;import org.springframework.security.authentication.*;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.util.HashSet;import java.util.Set;/** * @description: 自定义认证核心类 * @author zhaoxinguo * @date 2020/6/5 21:59 */@Componentpublic class LoginValidateAuthenticationProvider implements AuthenticationProvider &#123; @Resource private UserService userService; /** * 解密用的 */ @Resource private PasswordEncoder passwordEncoder; /** * 进行身份验证 * @param authentication * @return * @throws AuthenticationException */ @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; //获取输入的用户名 String username = authentication.getName(); //获取输入的明文 String rawPassword = (String) authentication.getCredentials(); //查询用户是否存在 User user = (User) userService.loadUserByUsername(username); if (!user.isEnabled()) &#123; throw new DisabledException("该账户已被禁用，请联系管理员"); &#125; else if (!user.isAccountNonLocked()) &#123; throw new LockedException("该账号已被锁定"); &#125; else if (!user.isAccountNonExpired()) &#123; throw new AccountExpiredException("该账号已过期，请联系管理员"); &#125; else if (!user.isCredentialsNonExpired()) &#123; throw new CredentialsExpiredException("该账户的登录凭证已过期，请重新登录"); &#125; //验证密码 if (!passwordEncoder.matches(rawPassword, user.getPassword())) &#123; throw new BadCredentialsException("输入密码错误!"); &#125; // TODO Spring Boot2 + Spring Security5 动态用户角色资源的权限管理(6) 添加代码 // 设置权限信息 Set&lt;GrantedAuthority&gt; grantedAuthorities = new HashSet&lt;&gt;(); for (com.javaymw.demo.sys.entity.Resource resource : user.getRole().getResources()) &#123; //资源key作为权限标识 grantedAuthorities.add(new SimpleGrantedAuthority(resource.getResourceKey())); user.setAuthorities(grantedAuthorities); &#125; return new UsernamePasswordAuthenticationToken(user, rawPassword, user.getAuthorities()); &#125; @Override public boolean supports(Class&lt;?&gt; authentication) &#123; //确保authentication能转成该类 return authentication.equals(UsernamePasswordAuthenticationToken.class); &#125;&#125; 这里要注意的是，我们把resource实体的resourceKey作为资源的权限标识，设置进grantedAuthorities集合里面，以便spring security根据注解@PreAuthorize自动权限判断 由于我们设计的用户与角色是一对一关联，所以我们这里GrantedAuthority集合就只有一条角色信息数据 然后就是自定义权限不足handler PerAccessDeniedHandler.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-07 11:50 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.core.handler;import com.alibaba.fastjson.JSONObject;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.web.access.AccessDeniedHandler;import org.springframework.stereotype.Component;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Map;/** * @description: 自定义权限不足handler * @author zhaoxinguo * @date 2020/6/7 11:49 */@Componentpublic class PerAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; //登录成功返回 Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(2); paramMap.put("code", "503"); paramMap.put("message", accessDeniedException.getMessage()); //设置返回请求头 response.setContentType("application/json;charset=utf-8"); //写出流 PrintWriter out = response.getWriter(); out.write(JSONObject.toJSONString(paramMap)); out.flush(); out.close(); &#125;&#125; 最后我们看看Spring Security配置类的变化： SecurityConfig.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 21:58 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.config;import com.javaymw.demo.core.LoginValidateAuthenticationProvider;import com.javaymw.demo.core.handler.LoginFailureHandler;import com.javaymw.demo.core.handler.LoginSuccessHandler;import com.javaymw.demo.core.handler.PerAccessDeniedHandler;import com.javaymw.demo.sys.service.UserService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;import org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;import javax.annotation.Resource;import javax.sql.DataSource;/** * @description: Spring Security 核心配置类 * @author zhaoxinguo * @date 2020/6/5 21:57 */@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; //数据源 @Resource private DataSource dataSource; //用户业务层 @Resource private UserService userService; //自定义认证 @Resource private LoginValidateAuthenticationProvider loginValidateAuthenticationProvider; //登录成功handler @Resource private LoginSuccessHandler loginSuccessHandler; //登录失败handler @Resource private LoginFailureHandler loginFailureHandler; //权限不足handler @Resource private PerAccessDeniedHandler perAccessDeniedHandler; /** * 权限核心配置 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; //基础设置 http.httpBasic()//配置HTTP基本身份验证 .and() .authorizeRequests() .anyRequest().authenticated()//所有请求都需要认证 .and() .formLogin() //登录表单 .loginPage("/login")//登录页面url .loginProcessingUrl("/login")//登录验证url .defaultSuccessUrl("/index")//成功登录跳转 .successHandler(loginSuccessHandler)//成功登录处理器 .failureHandler(loginFailureHandler)//失败登录处理器 .permitAll()//登录成功后有权限访问所有页面 .and() .exceptionHandling().accessDeniedHandler(perAccessDeniedHandler)//设置权限不足handler .and() .rememberMe()//记住我功能 .userDetailsService(userService)//设置用户业务 .tokenRepository(persistentTokenRepository())//设置持久化token .tokenValiditySeconds(24 * 60 * 60);//记住登录1天(24小时 *60分钟 * 60秒) //关闭csrf跨域攻击防御 http.csrf().disable(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //这里要设置自定义认证 auth.authenticationProvider(loginValidateAuthenticationProvider); &#125; /** * BCrypt加密 * @return */ @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; /** * 记住我功能，持久化的token服务 * @return */ @Bean public PersistentTokenRepository persistentTokenRepository()&#123; JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl(); //数据源设置 tokenRepository.setDataSource(dataSource); //启动的时候创建表，这里只执行一次，第二次就注释掉，否则每次启动都重新创建表 /*tokenRepository.setCreateTableOnStartup(true);*/ return tokenRepository; &#125;&#125; 在Spring Security配置文件中，我们只需要设置PerAccessDeniedHandler就可以了，还要记得在头部添加@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled=true)注解，以启动spring security注解生效 接下来就是前端页面和控制层： UserContorller.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 22:01 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.sys.controller;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * @description: TODO * @author zhaoxinguo * @date 2020/6/5 22:01 */@Controller@RequestMapping("/")public class UserController &#123; /** * 登录页面跳转 * @return */ @GetMapping(value = "/login") public String login() &#123; return "login.html"; &#125; /** * index页跳转 * @return */ @GetMapping("index") public String index() &#123; return "index.html"; &#125; /** * menu1 * @return */ @PreAuthorize("hasAuthority('menu1')") @GetMapping("menu1") @ResponseBody public String menu1() &#123; return "menu1"; &#125; /** * menu2 * @return */ @PreAuthorize("hasAuthority('menu2')") @GetMapping("menu2") @ResponseBody public String menu2() &#123; return "menu2"; &#125; /** * menu3 * @return */ @PreAuthorize("hasAuthority('menu3')") @GetMapping("menu3") @ResponseBody public String menu3() &#123; return "menu3"; &#125;&#125; 这里要注意的是，每个需要权限判断的方法中，都需要增加@PreAuthorize(“hasAuthority(‘key’)”)注解，否则权限判断不生效，key对应数据库资源表中的资源标识字段 index.html12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;index页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index页&lt;br/&gt;&lt;br/&gt;&lt;button id="menu1Btn" type="button" onclick="sendAjax('/menu1')"&gt;菜单1&lt;/button&gt;&lt;button id="menu2Btn" type="button" onclick="sendAjax('/menu2')"&gt;菜单2&lt;/button&gt;&lt;button id="menu3Btn" type="button" onclick="sendAjax('/menu3')"&gt;菜单3&lt;/button&gt;&lt;script src="http://libs.baidu.com/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function sendAjax(url) &#123; $.ajax(&#123; type: "GET", url: url, dataType: "text", success: function (data) &#123; console.log(data); &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里简单的说说数据库的数据 用户表：admin、teacher和student 角色表：管理员、教师和学生 资源表：menu1、menu2、menu3 对应权限：管理员：menu1、menu2、menu3 教师：menu1、menu2 学生：meun1 下面我们看看效果，登录页： index页： 这里我们先用admin管理员角色登录，然后点击所有菜单： 可以看到数据正常，并且已经访问到了所有资源菜单 然后我们用 teacher教师角色 登录，也是点击所有菜单： 会发现，在点击第三个菜单的时候，会返回没有权限访问 我们再用 student学生角色 登录，也是点击所有菜单： 这里说明我们的动态权限资源管理都生效了 那么文章就介绍到这里，在这里留了个坑，一般系统是不会让用户去点击了菜单才发现没有权限访问，而是针对不同的用户，动态显示不同的菜单，这个内容小编下篇文章就会讲解 结束语那么基本代码和效果也演示完毕了 源码获取方式加加入QQ交流群(715224124)，进群找群主要源码，如果有问题，可以提出疑问，群主会尽量帮助解决~ 希望能帮助到大家，如果有不好或者错误的地方希望能多多提出，谢谢大家~]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2 + Spring Security5 基于Redis的Spring Session管理(5)]]></title>
    <url>%2F2020%2F06%2F07%2FSpring-Boot2-Spring-Security5-%E5%9F%BA%E4%BA%8ERedis%E7%9A%84Spring-Session%E7%AE%A1%E7%90%86-5-1%2F</url>
    <content type="text"><![CDATA[前言前面几篇文章介绍了如何在Spring Boot 引入Security，并实现自定义登录，以及记住我功能 那么这篇文章，是想讲述下关于Session在Spring Security的管理以及实现过程 简单流程在传统Web应用中，一般都是是使用tomcat、weblogic、jboss等Web容器去部署应用，然后每个Web项目部署在对应一个或多个Tomcat(很少会这样)中，每个Web项目是相互独立的，每个项目都会拥有自己的Session，并且是相互独立的，传统部署方案如图： 假如说现在有这么个需求，就是说现在有三个项目A、B和C，如上图所示，那么现在如果我想登录了其中任意一个项目系统之后，接下来再进入其他项目系统的时候，可以不需要再次登录而直接进入，这就是单点登录 那么，目前来看，各个项目的Session都是独立的，要实现起来是非常复杂的。对此，为了解决这个问题，这里就需要让这三个项目都共享同一个Session，就可以完美解决，那么实现思路就是把Session存入中间件中，当需要认证的时候就从中间件中去取出判断，如图： 中间件一般就是使用Redis/Memcache去存储Session，大致上是这么个流程当然，Session存储在中间件上也是有很多其他好处，像服务器重启了Session也不会被销毁等等 那么，这里讲了那么多，目的是为了说明整合Spring Session与Redis的原因，那么下面开始展示代码 实现还是基于前面几篇文章的代码上，我们要引入了Spring Session和Redis依赖： 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Lettuce pool 连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; 这里要说明下，Redis的连接方式一般分为Jedis 和Lettuce ，相信大家对Jedis会比较熟悉，不过在Spring Boot2.x之后，已经默认为Lettuce连接方式 Lettuce是基于Netty框架，通过异步方式可以更好的节省系统资源，并且能在多个线程间并发访问，满足了多线程环境要求，这也是让博主转向了Lettuce的原因 yml配置如下： application.yml12345678910111213141516171819202122spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: root jpa: database: MYSQL show-sql: true hibernate: ddl-auto: update database-platform: org.hibernate.dialect.MySQL5InnoDBDialect redis: database: 0 #索引 host: 127.0.0.1 port: 6379 password: #修改成对应自己的redis密码 lettuce: pool: max-active: 8 #最大连接数 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 这里只是新增了redis的基础信息配置 接下来看看Spring Session配置类： SessionConfig.java1234567891011121314151617181920212223/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-06 15:03 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.config;import org.springframework.context.annotation.Configuration;import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;/** * @description: Spring Session配置类 * @author zhaoxinguo * @date 2020/6/6 15:03 */@Configuration@EnableRedisHttpSessionpublic class SessionConfig &#123;&#125; 对的，你没看错，只要加上@EnableRedisHttpSession注解就默认开启了Spring Session 然后就是Redis的配置类： RedisConfig.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-06 15:05 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.config;import com.alibaba.fastjson.support.spring.FastJsonRedisSerializer;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import javax.annotation.Resource;/** * @description: Redis的配置类 * @author zhaoxinguo * @date 2020/6/6 15:05 */@Configuration@EnableCaching //缓存启动注解public class RedisConfig &#123; //redis连接工厂 @Resource private LettuceConnectionFactory lettuceConnectionFactory; /** * 配置自定义redisTemplate * @return */ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(lettuceConnectionFactory); //使用FastJsonRedisSerializer序列化和反序列化redis的key、value值 template.setValueSerializer(fastJsonRedisSerializer()); template.setKeySerializer(fastJsonRedisSerializer()); template.afterPropertiesSet(); return template; &#125; /** * fastjson序列化Bean * @return */ @Bean public FastJsonRedisSerializer&lt;?&gt; fastJsonRedisSerializer() &#123; return new FastJsonRedisSerializer&lt;&gt;(Object.class); &#125;&#125; 到这里，实现的代码已经演示完毕了，是不是非常简洁。因为这里Spring Security都已经帮我们实现好了session存入redis中，我们只要配置下就可以用了 启动项目前要先启动redis服务，我们看看效果 当我点击登录并成功登录后，看看redis： 可有清楚的看到，redis已经存储了session相关信息 结束语那么基本代码和效果也演示完毕了 源码获取方式加加入QQ交流群(715224124)，进群找群主要源码，如果有问题，可以提出疑问，群主会尽量帮助解决~ 希望能帮助到大家，如果有不好或者错误的地方希望能多多提出，谢谢大家~]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2 + Spring Security5 记住我功能(4)]]></title>
    <url>%2F2020%2F06%2F07%2FSpring-Boot2-Spring-Security5-%E8%AE%B0%E4%BD%8F%E6%88%91%E5%8A%9F%E8%83%BD-4%2F</url>
    <content type="text"><![CDATA[前言上篇文章介绍了Spring Boot Security配置了自定义登录本篇文章，博主会介绍实现记住我功能 开始Spring Security记住我功能，其实就是就是当用户勾选了”记住我”然后成功认证登录了，那在有效时间内免登录直接进入那么，Spring Security实现记住我的方式有两种： 1.本地存储(cookie) 2.持久化存储 这里博主简单的说下流程，当Spring Security用户登录成功的时候，它会生成授权信息(token)然后方法一的话，Spring Security会把token传输到用户本地浏览器cookie里面存储起来方法二的话就是把token存入数据库中，那么相信大家也就清楚了 像token这种敏感的数据，是不建议暴露用户那边的，因为这样很容易会被中间人劫持，又或者被伪造请求(CSRF)，所以博主是建议使用第二种办法 那么下面开始展示实现代码，，我们继上篇的代码，在Spring Security配置类上添加持久化配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 21:58 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.config;import com.javaymw.demo.core.LoginValidateAuthenticationProvider;import com.javaymw.demo.core.handler.LoginFailureHandler;import com.javaymw.demo.core.handler.LoginSuccessHandler;import com.javaymw.demo.sys.service.UserService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;import org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;import javax.annotation.Resource;import javax.sql.DataSource;/** * @description: Spring Security 核心配置类 * @author zhaoxinguo * @date 2020/6/5 21:57 */@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(securedEnabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; //数据源 @Resource private DataSource dataSource; //用户业务层 @Resource private UserService userService; //自定义认证 @Resource private LoginValidateAuthenticationProvider loginValidateAuthenticationProvider; //登录成功handler @Resource private LoginSuccessHandler loginSuccessHandler; //登录失败handler @Resource private LoginFailureHandler loginFailureHandler; /** * 权限核心配置 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; //基础设置 http.httpBasic()//配置HTTP基本身份验证 .and() .authorizeRequests() .anyRequest().authenticated()//所有请求都需要认证 .and() .formLogin() //登录表单 .loginPage("/login")//登录页面url .loginProcessingUrl("/login")//登录验证url .defaultSuccessUrl("/index")//成功登录跳转 .successHandler(loginSuccessHandler)//成功登录处理器 .failureHandler(loginFailureHandler)//失败登录处理器 .permitAll()//登录成功后有权限访问所有页面 .and() .rememberMe()//记住我功能 .userDetailsService(userService)//设置用户业务 .tokenRepository(persistentTokenRepository())//设置持久化token .tokenValiditySeconds(24 * 60 * 60);//记住登录1天(24小时 *60分钟 * 60秒) //关闭csrf跨域攻击防御 http.csrf().disable(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //这里要设置自定义认证 auth.authenticationProvider(loginValidateAuthenticationProvider); &#125; /** * BCrypt加密 * @return */ @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; /** * 记住我功能，持久化的token服务 * @return */ @Bean public PersistentTokenRepository persistentTokenRepository()&#123; JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl(); //数据源设置 tokenRepository.setDataSource(dataSource); //启动的时候创建表，这里只执行一次，第二次就注释掉，否则每次启动都重新创建表 tokenRepository.setCreateTableOnStartup(true); return tokenRepository; &#125;&#125; 首先，要想存储到数据库种，那是需要创建数据库表存储，这里通过tokenRepository.setCreateTableOnStartup(true)方法就可以让Spring Security自动创建数据库表，不过记得下次启动的时候一定要注释起来 其次就是在权限核心配置方法中追加了.rememberMe()的一系列配置。 接下来，在前端登录页面上，需要新添加一个复选框，然后加上属性name=”remember-me”即可记住我 login.html1&lt;input type="checkbox" name="remember-me"/&gt; 完整代码如下： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;登录页&lt;/h2&gt;&lt;form id="loginForm" action="/login" method="post"&gt; 用户名：&lt;input type="text" id="username" name="username"&gt;&lt;br/&gt;&lt;br/&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type="password" id="password" name="password"&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type="checkbox" name="remember-me"/&gt;记住我&lt;br/&gt;&lt;br/&gt; &lt;button id="loginBtn" type="button"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;script src="http://libs.baidu.com/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $("#loginBtn").click(function () &#123; $.ajax(&#123; type: "POST", url: "/login", data: $("#loginForm").serialize(), dataType: "JSON", success: function (data) &#123; console.log(data); //window.location.href = "/index"; &#125; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 开始启动程序，之后打开数据库会发现自动创建了存储token的persistent_logins表： 然后再看看登录效果： 当我点击登录并登录成功后，persistent_logins表就多了条信息： 那么基本代码和效果也演示完毕了 源码获取方式加加入QQ交流群(715224124)，进群找群主要源码，如果有问题，可以提出疑问，群主会尽量帮助解决~ 希望能帮助到大家，如果有不好或者错误的地方希望能多多提出，谢谢大家~]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2 + Spring Security5 自定义登录验证(3)]]></title>
    <url>%2F2020%2F06%2F07%2FSpring-Boot2-Spring-Security5-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81-3%2F</url>
    <content type="text"><![CDATA[前言上篇文章介绍了如何在Spring Boot引入Security 接下来，博主会简单的介绍下如何自定义登录配置 开始首先，我们要有数据库的用户表，这里我用的是mysql5.6表结构如下： 字段的话就不详细介绍了，相信看名字就能懂 整体demo结构如图： 虽然说是demo，但是本着严格务实的态度，也是遵守MVC的调用流程，所以包可能会有点繁琐 这里简单的说下这个登录验证的流程，以便大家更好的理解下面的代码，先看图： 绿色背景色为自定义实现的，也就是下面会出现的类方法对于中间件那块来说是暂时没有的，可以不管先，后面的文章会引入，到时候再作介绍 当然，Spring Security认证的流程是没有那么简单的，这里只是给大家方便理解才简化了很多流程 下面开始展示代码 由于需要操作数据库，以及展示页面等，小编这里就需要引入持久层以及前端页面一些框架这里博主用的是Spring Data Jpa，前端用的是Thymeleaf，Maven代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.javaymw&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 添加完相关的依赖，还是到项目的根目录下，执行maven的编译命令，把相关的jar下载下来：mvn clean compile yml的配置不需要多大的修改，这次只是配置了数据源和jpa的一些基础属性，代码如下： 1234567891011121314151617server: tomcat: uri-encoding: UTF-8 port: 8080spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: root jpa: database: MYSQL show-sql: true hibernate: ddl-auto: update database-platform: org.hibernate.dialect.MySQL5InnoDBDialect 这里要注意的是，当引入的mysql-connector-java版本是6.0以上的话，那驱动就是： com.mysql.cj.jdbc.Driver 中间是多个cj的还有就是在数据源url后面要加上serverTimezone=UTC这条参数，否则也是会报错的 jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC 接下来就是编写spring security的配置类： SecurityConfig .java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 21:58 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.config;import com.javaymw.demo.core.LoginValidateAuthenticationProvider;import com.javaymw.demo.core.handler.LoginFailureHandler;import com.javaymw.demo.core.handler.LoginSuccessHandler;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import javax.annotation.Resource;/** * @description: Spring Security 核心配置类 * @author zhaoxinguo * @date 2020/6/5 21:57 */@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; //自定义认证 @Resource private LoginValidateAuthenticationProvider loginValidateAuthenticationProvider; //登录成功handler @Resource private LoginSuccessHandler loginSuccessHandler; //登录失败handler @Resource private LoginFailureHandler loginFailureHandler; /** * 权限核心配置 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; //基础设置 http.httpBasic()//配置HTTP基本身份验证 .and() .authorizeRequests() .anyRequest().authenticated()//所有请求都需要认证 .and() .formLogin() //登录表单 .loginPage("/login")//登录页面url .loginProcessingUrl("/login")//登录验证url .defaultSuccessUrl("/index")//成功登录跳转 .successHandler(loginSuccessHandler)//成功登录处理器 .failureHandler(loginFailureHandler)//失败登录处理器 .permitAll();//登录成功后有权限访问所有页面 //关闭csrf跨域攻击防御 http.csrf().disable(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //这里要设置自定义认证 auth.authenticationProvider(loginValidateAuthenticationProvider); &#125; /** * BCrypt加密 * @return */ @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 注意，Spring Security配置类必须继承WebSecurityConfigurerAdapter类才会生效 这里BCrypt加密方式是官方推荐使用的，还有就是Spring Security5.x是不需要配置加密方式的，因为它可以匹配多种加密方式以用来解密，只需要在密码前面加上加密方式即可，格式如下： {加密方式}密文 例如： {MD5}e10adc3949ba59abbe56e057f20f883e {bcrypt}$2a101010bOZ5qFQS4OojeLUdb6K8.OU/KrVR8vzdo7QaCNKNG4oaIYUrAGKJ2 这样就可以实现兼容多个加密方式，可以说是挺人性化的，不过我这里还是规定死了哈哈哈哈 然后就是编写User实体类和UserService实现类： User.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 22:01 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.sys.entity;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import javax.persistence.*;import java.util.Collection;/** * @description: TODO * @author zhaoxinguo * @date 2020/6/5 22:01 */@Entity@Table(name = "sys_user")public class User implements UserDetails &#123; //id @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column protected Integer id; //用户名 @Column private String username; //密码 @Column(nullable = false) private String password; /** * 是否锁定 * true: 未锁定 * false: 锁定 */ @Column private boolean lockedFlag; //security存储权限认证用的 @Transient private Collection&lt;? extends GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; /** * 用户账号是否过期 * true: 未过期 * false: 已过期 * * @return */ @Override public boolean isAccountNonExpired() &#123; return true; &#125; /** * 用户账号是否被锁定 * true: 未锁定 * false: 锁定 * * @return */ @Override public boolean isAccountNonLocked() &#123; return lockedFlag; &#125; /** * 用户账号凭证(密码)是否过期 * 简单的说就是可能会因为修改了密码导致凭证过期这样的场景 * true: 过期 * false: 无效 * * @return */ @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; /** * 用户账号是否被启用 * true: 启用 * false: 未启用 * * @return */ @Override public boolean isEnabled() &#123; return true; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public boolean isLockedFlag() &#123; return lockedFlag; &#125; public void setLockedFlag(boolean lockedFlag) &#123; this.lockedFlag = lockedFlag; &#125; public void setAuthorities(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this.authorities = authorities; &#125;&#125; 这里要说明下，UserDetails是Spring Security提供的一个保存用户账号信息的接口，详情请看代码注释，因为有些地方是没有用到的，所以就写死了很多属性，大家可根据实际需求来修改使用 UserService.java12345678910111213141516171819202122232425262728293031323334353637/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 22:04 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.sys.service;import com.javaymw.demo.sys.entity.User;import com.javaymw.demo.sys.repository.UserRepository;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * @description: TODO * @author zhaoxinguo * @date 2020/6/5 22:04 */@Servicepublic class UserService implements UserDetailsService &#123; @Resource private UserRepository userRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = userRepository.findUserByUsername(username); if (user == null) &#123; throw new UsernameNotFoundException("不存在该用户!"); &#125; return user; &#125;&#125; 同理 UserDetailsService 也是是spring security提供的，这里实现了加载用户名称的方法，目的是为了获取用户信息，以便接下来的认证 UserRepository .java1234567891011121314151617181920212223/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 22:03 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.sys.repository;import com.javaymw.demo.sys.entity.User;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;/** * @description: TODO * @author zhaoxinguo * @date 2020/6/5 22:03 */@Repositorypublic interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123; User findUserByUsername(String username);&#125; 这个相信不用多说了吧 下面就是自定义认证的核心代码： LoginValidateAuthenticationProvider.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 21:59 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.core;import com.javaymw.demo.sys.entity.User;import com.javaymw.demo.sys.service.UserService;import org.springframework.security.authentication.*;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;import javax.annotation.Resource;/** * @description: 自定义认证核心类 * @author zhaoxinguo * @date 2020/6/5 21:59 */@Componentpublic class LoginValidateAuthenticationProvider implements AuthenticationProvider &#123; @Resource private UserService userService; /** * 解密用的 */ @Resource private PasswordEncoder passwordEncoder; /** * 进行身份验证 * @param authentication * @return * @throws AuthenticationException */ @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; //获取输入的用户名 String username = authentication.getName(); //获取输入的明文 String rawPassword = (String) authentication.getCredentials(); //查询用户是否存在 User user = (User) userService.loadUserByUsername(username); if (!user.isEnabled()) &#123; throw new DisabledException("该账户已被禁用，请联系管理员"); &#125; else if (!user.isAccountNonLocked()) &#123; throw new LockedException("该账号已被锁定"); &#125; else if (!user.isAccountNonExpired()) &#123; throw new AccountExpiredException("该账号已过期，请联系管理员"); &#125; else if (!user.isCredentialsNonExpired()) &#123; throw new CredentialsExpiredException("该账户的登录凭证已过期，请重新登录"); &#125; //验证密码 if (!passwordEncoder.matches(rawPassword, user.getPassword())) &#123; throw new BadCredentialsException("输入密码错误!"); &#125; return new UsernamePasswordAuthenticationToken(user, rawPassword, user.getAuthorities()); &#125; @Override public boolean supports(Class&lt;?&gt; authentication) &#123; //确保authentication能转成该类 return authentication.equals(UsernamePasswordAuthenticationToken.class); &#125;&#125; 这里通过实现AuthenticationProvider 认证授权类，以达到自定义登录的效果，注意，这里是结合了之前实现的loadUserByUsername方法去获取用户信息，以及用户状态去判断登录是否能通过 接下来就是handler代码： LoginSuccessHandler.java1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 22:01 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.core.handler;import com.alibaba.fastjson.JSONObject;import org.springframework.security.core.Authentication;import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;import org.springframework.stereotype.Component;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Map;/** * @description: 登陆成功处理handler * @author zhaoxinguo * @date 2020/6/5 22:00 */@Componentpublic class LoginSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws ServletException, IOException &#123; //登录成功返回 Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(2); paramMap.put("code", "200"); paramMap.put("message", "登录成功!"); //设置返回请求头 response.setContentType("application/json;charset=utf-8"); //写出流 PrintWriter out = response.getWriter(); out.write(JSONObject.toJSONString(paramMap)); out.flush(); out.close(); &#125;&#125; LoginFailureHandler.java1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 2020-06-05 22:00 * Created by zhaoxinguo * Version 2.0.0 */package com.javaymw.demo.core.handler;import com.alibaba.fastjson.JSONObject;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;import org.springframework.stereotype.Component;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Map;/** * @description: 登录失败处理handler * @author zhaoxinguo * @date 2020/6/5 22:00 */@Componentpublic class LoginFailureHandler extends SimpleUrlAuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; //登录失败信息返回 Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(2); paramMap.put("code", "500"); paramMap.put("message", exception.getMessage()); //设置返回请求头 response.setContentType("application/json;charset=utf-8"); //写出流 PrintWriter out = response.getWriter(); out.write(JSONObject.toJSONString(paramMap)); out.flush(); out.close(); &#125;&#125; 那么到这里，也已经差不多了，现在还差的是登录的前端页面和一些效果 login.html123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;登录页&lt;/h2&gt;&lt;form id="loginForm" action="/login" method="post"&gt; 用户名：&lt;input type="text" id="username" name="username"&gt;&lt;br/&gt;&lt;br/&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type="password" id="password" name="password"&gt;&lt;br/&gt;&lt;br/&gt; &lt;button id="loginBtn" type="button"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;script src="http://libs.baidu.com/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $("#loginBtn").click(function () &#123; $.ajax(&#123; type: "POST", url: "/login", data: $("#loginForm").serialize(), dataType: "JSON", success: function (data) &#123; console.log(data); //window.location.href = "/index"; &#125; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里为了方便演示，就直接在前端输出登录信息，下面看看演示图： 这里我在数据库加了条登录数据，数据默认用户脚本如下，用户名、密码（admin/123456)： 1INSERT INTO `test`.`sys_user` (`id`, `locked_flag`, `password`, `username`) VALUES ('1', b'1', '$2a$10$UNVzCpRC3ND2XrCu8rZWJ.OkAzpyP651itODJiKTMOpqLMWrTLcEi', 'admin'); 这里我在数据库加了条登录数据，当填正确账号点击登录的时候，显示是成功的 随便输入个错误的密码则是： 输入个不存在的用户名则是： 修改用户状态为锁定则是： 那么基本代码和效果也演示完毕了 源码获取方式加加入QQ交流群(715224124)，进群找群主要源码，如果有问题，可以提出疑问，群主会尽量帮助解决~ 希望能帮助到大家，如果有不好或者错误的地方希望能多多提出，谢谢大家~]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2 + Spring Security5 简单使用教程(2)]]></title>
    <url>%2F2020%2F06%2F07%2FSpring-Boot2-Spring-Security5-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-2%2F</url>
    <content type="text"><![CDATA[前言这篇文章博主给大家展示Spring Boot2 + Spring Security5的搭建好的，废话不多说，进入主题 搭建环境首先我们登录Spring官方的创建demo的网址：https://start.spring.io/ 选择对应的Spring Boot版本，选择jdk版本，见下图，然后创建项目 创建好项目，复制到你的本地工程目录下，见下图，然后先编译一下，让项目依赖的jar下载到本地仓库 编译成功后，导入项目到你的开发工具，我这里是IDEA（社区版）导入成功后，接下来就可以添加Spring Security的依赖了：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 添加完Spring Security的依赖后，需要在开发工具再编译项目下才能下载下Spring Security对应的依赖jar添加完Spring Security的依赖后，这个项目还启动不了，还需要添加下Spring Boot的 Web模块才行1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 添加完Web模块的依赖，同样重复刚才的编译动作然后就可以启动项目，启动成功后访问 http://127.0.0.1:8080就可以看到，security已经生效了，这里的登录页面是spring security自带的 那么到这里，简单的引入security的工作已经完成了结束语下篇文章内容是自定义登录页面的集成，谢谢大家~ 源码获取方式加加入QQ交流群(715224124)，进群找群主要源码，如果有问题，可以提出疑问，群主会尽量帮助解决~ 希望能帮助到大家，如果有不好或者错误的地方希望能多多提出，谢谢大家~]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2 + Spring Security5 系列搭建教程开头篇(1)]]></title>
    <url>%2F2020%2F06%2F07%2FSpring-Boot2-Spring-Security5-%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%E5%BC%80%E5%A4%B4%E7%AF%87-1%2F</url>
    <content type="text"><![CDATA[随便说点因为公司项目重构的原因，博主需要搭建个Spring Boot全家桶框架，但是网上资料要不就是比较旧版本的，要不就是不完整的。所以博主在大量查阅官方各种英文文档，和一些相关教程，总结出一系列Spring Boot2 + Spring Security5的搭建以及简单入门 在这里，博主会写出搭建过程以及自己的一些理解，当然因为真正落地的程序是比较复杂的，所以博客上写下的都是简化版demo以便于理解。每一篇文章的链接如下： 1.Spring Boot2 + Spring Security5 系列搭建教程开头篇(1) 2.Spring Boot2 + Spring Security5 简单使用教程(2) 3.Spring Boot2 + Spring Security5 自定义登录验证(3) 4.Spring Boot2 + Spring Security5 记住我功能(4) 5.Spring Boot2 + Spring Security5 基于Redis的Spring Session管理(5) 6.Spring Boot2 + Spring Security5 用户角色资源管理的权限管理(6) 7.Spring Boot2 + Spring Security5 资源菜单按钮动态显示(7) 8.Spring Boot2 + Spring Security5 基于JWT实现的token认证方案(8) 9.Spring Boot2 + Spring Security5 基于JWT实现的token刷新方案(9) 当然，博主也会把这个demo源码放出来给大家借鉴下 源码获取方式加加入QQ交流群(715224124)，进群下载即可，如果有问题，可以提出疑问，群主会尽量帮助解决~ 希望能帮助到大家，如果有不好或者错误的地方希望能多多提出，谢谢大家~]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 3.x企业应用开发实战（高清版）.pdf、随书源码、下载]]></title>
    <url>%2F2020%2F05%2F20%2FSpring-3-x%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%88%E9%AB%98%E6%B8%85%E7%89%88%EF%BC%89-pdf%E3%80%81%E9%9A%8F%E4%B9%A6%E6%BA%90%E7%A0%81%E3%80%81%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Spring 3.x企业应用开发实战（高清版）.pdf +随书源码一：Spring 3.x企业应用开发实战（高清版）.pdf 二：Spring 3.x企业应用开发实战（高清版）.章节介绍 三：Spring 3.x企业应用开发实战（高清版）.随书源码 四：文档和源码获取方式，扫码加入QQ交流群找群主获取 五：温馨提示，加入QQ群需要个鸡腿钱，大佬请绕道]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java实现文件切片和合并]]></title>
    <url>%2F2020%2F04%2F13%2FJava%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%88%87%E7%89%87%E5%92%8C%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[Java实现文件切片和合并摘要日常工作中，会有对文件传输的需求，那么文件传输中，如果是小文件，可以一次性的传输过去，那么如果是比较大的文件呢，比如：十几MB的呢如果一次性传输肯定很慢，并且还有带宽占用大、文件传输慢的问题，这里面我们就可以通过对文件切片后，分段传输，下面是具体的代码实现 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 04-13 11:08 * Created by zhaoxinguo * Version 2.0.0 */package org.javaymw.base.utils;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;/** * @description: Java实现文件切片和合并 * @author zhaoxinguo * @date 2020/4/13 11:08 */public class FileSplitUtil &#123; /** * 文件拆分 * @param file * @param count */ public static void getSplitFile(String file, int count) &#123; //预分配文件所占用的磁盘空间，在磁盘创建一个指定大小的文件，“r”表示只读，“rw”支持随机读写 try &#123; RandomAccessFile raf = new RandomAccessFile(new File(file), "r"); //计算文件大小 long length = raf.length(); System.out.println(length); //计算文件切片后每一份文件的大小 long maxSize = length / count; System.out.println(maxSize); //定义初始文件的偏移量(读取进度) long offset = 0L; //开始切割文件 //count-1最后一份文件不处理 for(int i = 0; i &lt; count - 1; i++)&#123; //标记初始化 long fbegin = offset; //分割第几份文件 long fend = (i+1) * maxSize; //写入文件 offset = getWrite(file, i, fbegin, fend); &#125; //剩余部分文件写入到最后一份(如果不能平平均分配的时候) if (length - offset &gt; 0) &#123; //写入文件 getWrite(file, count-1, offset, length); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 指定文件每一份的边界，写入不同文件中 * @param file 源文件 * @param index 源文件的顺序标识 * @param begin 开始指针的位置 * @param end 结束指针的位置 * @return long */ public static long getWrite(String file, int index, long begin, long end) &#123; long endPointer = 0L; try &#123; //申明文件切割后的文件磁盘 RandomAccessFile in = new RandomAccessFile(new File(file), "r"); //定义一个可读，可写的文件并且后缀名为.tmp的二进制文件 RandomAccessFile out = new RandomAccessFile(new File(file + "_" + index + ".tmp"), "rw"); //申明具体每一文件的字节数组 byte[] b = new byte[1024]; int n = 0; //从指定位置读取文件字节流 in.seek(begin); //判断文件流读取的边界 while (in.getFilePointer() &lt;= end &amp;&amp; (n = in.read(b)) != -1) &#123; //从指定每一份文件的范围，写入不同的文件 out.write(b, 0, n); &#125; //定义当前读取文件的指针 endPointer = in.getFilePointer(); //关闭输入流 in.close(); //关闭输出流 out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return endPointer; &#125; /** * 文件合并 * @param file 指定合并文件 * @param tempFile 分割前的文件名 * @param tempCount 文件个数 */ public static void merge(String file, String tempFile, int tempCount) &#123; RandomAccessFile raf = null; try &#123; //申明随机读取文件RandomAccessFile raf = new RandomAccessFile(new File(file), "rw"); //开始合并文件，对应切片的二进制文件 for (int i = 0; i &lt; tempCount; i++) &#123; //读取切片文件 RandomAccessFile reader = new RandomAccessFile(new File(tempFile + "_" + i + ".tmp"), "r"); byte[] b = new byte[1024]; int n = 0; while ((n = reader.read(b)) != -1) &#123; //一边读，一边写 raf.write(b, 0, n); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; raf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; /** * 第一步 */ String file = "D:\\BaiduNetdiskDownload\\Beginning Spring Boot 2.pdf"; int count = 5; //1.根据现有的文件编写文件编写文件切片工具类 //2.写入到二进制临时文件 getSplitFile(file, count); /** * 第二步 */ //3.根据实际的需求合并指定数量的文件 String mergeFile = "D:\\BaiduNetdiskDownload\\Beginning Spring Boot 2_temp.pdf"; merge(mergeFile, file, count); &#125;&#125; 文件拆分1234567891011121314151617181920212223242526272829303132333435363738/** * 文件拆分 * @param file * @param count */public static void getSplitFile(String file, int count) &#123; //预分配文件所占用的磁盘空间，在磁盘创建一个指定大小的文件，“r”表示只读，“rw”支持随机读写 try &#123; RandomAccessFile raf = new RandomAccessFile(new File(file), "r"); //计算文件大小 long length = raf.length(); System.out.println(length); //计算文件切片后每一份文件的大小 long maxSize = length / count; System.out.println(maxSize); //定义初始文件的偏移量(读取进度) long offset = 0L; //开始切割文件 //count-1最后一份文件不处理 for(int i = 0; i &lt; count - 1; i++)&#123; //标记初始化 long fbegin = offset; //分割第几份文件 long fend = (i+1) * maxSize; //写入文件 offset = getWrite(file, i, fbegin, fend); &#125; //剩余部分文件写入到最后一份(如果不能平平均分配的时候) if (length - offset &gt; 0) &#123; //写入文件 getWrite(file, count-1, offset, length); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 指定文件每一份的边界，写入不同文件中12345678910111213141516171819202122232425262728293031323334353637383940/** * 指定文件每一份的边界，写入不同文件中 * @param file 源文件 * @param index 源文件的顺序标识 * @param begin 开始指针的位置 * @param end 结束指针的位置 * @return long */public static long getWrite(String file, int index, long begin, long end) &#123; long endPointer = 0L; try &#123; //申明文件切割后的文件磁盘 RandomAccessFile in = new RandomAccessFile(new File(file), "r"); //定义一个可读，可写的文件并且后缀名为.tmp的二进制文件 RandomAccessFile out = new RandomAccessFile(new File(file + "_" + index + ".tmp"), "rw"); //申明具体每一文件的字节数组 byte[] b = new byte[1024]; int n = 0; //从指定位置读取文件字节流 in.seek(begin); //判断文件流读取的边界 while (in.getFilePointer() &lt;= end &amp;&amp; (n = in.read(b)) != -1) &#123; //从指定每一份文件的范围，写入不同的文件 out.write(b, 0, n); &#125; //定义当前读取文件的指针 endPointer = in.getFilePointer(); //关闭输入流 in.close(); //关闭输出流 out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return endPointer;&#125; 文件合并1234567891011121314151617181920212223242526272829303132/** * 文件合并 * @param file 指定合并文件 * @param tempFile 分割前的文件名 * @param tempCount 文件个数 */public static void merge(String file, String tempFile, int tempCount) &#123; RandomAccessFile raf = null; try &#123; //申明随机读取文件RandomAccessFile raf = new RandomAccessFile(new File(file), "rw"); //开始合并文件，对应切片的二进制文件 for (int i = 0; i &lt; tempCount; i++) &#123; //读取切片文件 RandomAccessFile reader = new RandomAccessFile(new File(tempFile + "_" + i + ".tmp"), "r"); byte[] b = new byte[1024]; int n = 0; while ((n = reader.read(b)) != -1) &#123; //一边读，一边写 raf.write(b, 0, n); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; raf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码测试12345678910111213141516public static void main(String[] args) &#123; /** * 第一步 */ String file = "D:\\BaiduNetdiskDownload\\Beginning Spring Boot 2.pdf"; int count = 5; //1.根据现有的文件编写文件编写文件切片工具类 //2.写入到二进制临时文件 getSplitFile(file, count); /** * 第二步 */ //3.根据实际的需求合并指定数量的文件 String mergeFile = "D:\\BaiduNetdiskDownload\\Beginning Spring Boot 2_temp.pdf"; merge(mergeFile, file, count);&#125; 运行结果]]></content>
      <categories>
        <category>文件处理</category>
      </categories>
      <tags>
        <tag>文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti 5.16 Spring 集成]]></title>
    <url>%2F2020%2F04%2F09%2FActiviti-5-16-Spring-%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[Chapter 5. Spring 集成虽然没有Spring你也可以使用Activiti，但是我们提供了一些非常不错的集成特性。这一章我们将介绍这些特性。 ProcessEngineFactoryBean可以把流程引擎（ProcessEngine）作为一个普通的Spring bean进行配置。 类 org.activiti.spring.ProcessEngineFactoryBean是集成的切入点。 这个bean需要一个流程引擎配置来创建流程引擎。这也意味着在文档的配置这一章的介绍属性的创建和配置对于Spring来说也是一样的。对于Spring集成的配置和流程引擎bean看起来像这样： 1234567&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; ...&lt;/bean&gt;&lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration" /&gt;&lt;/bean&gt; 注意现在使用的 processEngineConfiguration bean 是 org.activiti.spring.SpringProcessEngineConfiguration 类。 事务我们将会一步一步地解释在Spring examples中公布的 SpringTransactionIntegrationTest 下面是我们使用这个例子的Spring配置文件（你可以在SpringTransactionIntegrationTest-context.xml找到它）以下展示的部分包括数据源（dataSource）， 事务管理器（transactionManager），流程引擎（processEngine）和Activiti引擎服务。 当把数据源（DataSource）传递给 SpringProcessEngineConfiguration （使用”dataSource”属性）之后，Activiti内部使用了一个org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy代理来封装传递进来的数据源（DataSource）。 这样做是为了确保从数据源（DataSource）获取的SQL连接能够与Spring的事物结合在一起发挥得更出色。这意味它不再需要在你的Spring配置中代理数据源（dataSource）了。 然而它仍然允许你传递一个TransactionAwareDataSourceProxy到SpringProcessEngineConfiguration中。在这个例子中并不会发生多余的包装。 为了确保在你的Spring配置中申明的一个TransactionAwareDataSourceProxy，你不能把使用它的应用交给Spring事物控制的资源。（例如 DataSourceTransactionManager 和JPATransactionManager需要非代理的数据源 ） 12345678910111213141516171819202122232425262728293031323334353637&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource"&gt; &lt;property name="driverClass" value="org.h2.Driver" /&gt; &lt;property name="url" value="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000" /&gt; &lt;property name="username" value="sa" /&gt; &lt;property name="password" value="" /&gt; &lt;/bean&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="transactionManager" ref="transactionManager" /&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;property name="jobExecutorActivate" value="false" /&gt; &lt;/bean&gt; &lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration" /&gt; &lt;/bean&gt; &lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" /&gt; &lt;bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService" /&gt; &lt;bean id="taskService" factory-bean="processEngine" factory-method="getTaskService" /&gt; &lt;bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService" /&gt; &lt;bean id="managementService" factory-bean="processEngine" factory-method="getManagementService" /&gt;... Spring配置文件的其余部分包含beans和我们将要在这个特有的例子中的配置： 1234567891011&lt;beans&gt; ... &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;bean id="userBean" class="org.activiti.spring.test.UserBean"&gt; &lt;property name="runtimeService" ref="runtimeService" /&gt; &lt;/bean&gt; &lt;bean id="printer" class="org.activiti.spring.test.Printer" /&gt;&lt;/beans&gt; 首先使用任意的一种Spring创建应用上下文的方式创建其Spring应用上下文。在这个例子中你可以使用类路径下面的XML资源来配置我们的Spring应用上下文： 12ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("org/activiti/examples/spring/SpringTransactionIntegrationTest-context.xml"); 或者, 如果它是一个测试的话: 1@ContextConfiguration("classpath:org/activiti/spring/test/transaction/SpringTransactionIntegrationTest-context.xml") 然后我们就可以得到Activiti的服务beans并且调用该服务上面的方法。ProcessEngineFactoryBean将会对该服务添加一些额外的拦截器，在Activiti服务上面的方法使用的是 Propagation.REQUIRED事物语义。所以，我们可以使用repositoryService去部署一个流程，如下所示： 123456RepositoryService repositoryService = (RepositoryService) applicationContext.getBean("repositoryService");String deploymentId = repositoryService .createDeployment() .addClasspathResource("org/activiti/spring/test/hello.bpmn20.xml") .deploy() .getId(); 其他相同的服务也是同样可以这么使用。在这个例子中，Spring的事物将会围绕在userBean.hello()上，并且调用Activiti服务的方法也会加入到这个事物中。 12UserBean userBean = (UserBean) applicationContext.getBean("userBean");userBean.hello(); 这个UserBean看起来像这样。记得在上面Spring bean的配置中我们把repositoryService注入到userBean中。 1234567891011121314151617public class UserBean &#123; /** 由Spring注入 */ private RuntimeService runtimeService; public void setRuntimeService(RuntimeService runtimeService) &#123; this.runtimeService = runtimeService; &#125; @Transactional public void hello() &#123; //这里，你可以在你们的领域模型中做一些事物处理。 //当在调用Activiti RuntimeService的startProcessInstanceByKey方法时， //它将会结合到同一个事物中。 runtimeService.startProcessInstanceByKey("helloProcess"); &#125;&#125; 表达式当使用ProcessEngineFactoryBean时候，默认情况下，在BPMN流程中的所有表达式都将会’看见’所有的Spring beans。 它可以限制你在表达式中暴露出的beans或者甚至可以在你的配置中使用一个Map不暴露任何beans。下面的例子暴露了一个单例bean（printer），可以把”printer”当作关键字使用. 想要不暴露任何beans，仅仅只需要在SpringProcessEngineConfiguration中传递一个空的list作为’beans’的属性。当不设置’beans’的属性时，在应用上下文中Spring beans都是可以使用的。 12345678910&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; ... &lt;property name="beans"&gt; &lt;map&gt; &lt;entry key="printer" value-ref="printer" /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id="printer" class="org.activiti.examples.spring.Printer" /&gt; 现在暴露出来的beans就可以在表达式中使用：例如，在SpringTransactionIntegrationTest中的 hello.bpmn20.xml展示的是如何使用UEL方法表达式去调用Spring bean的方法： 123456789101112131415&lt;definitions id="definitions" ...&gt; &lt;process id="helloProcess"&gt; &lt;startEvent id="start" /&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="print" /&gt; &lt;serviceTask id="print" activiti:expression="#&#123;printer.printMessage()&#125;" /&gt; &lt;sequenceFlow id="flow2" sourceRef="print" targetRef="end" /&gt; &lt;endEvent id="end" /&gt; &lt;/process&gt;&lt;/definitions&gt; 这里的 Printer 看起来像这样： 123456public class Printer &#123; public void printMessage() &#123; System.out.println("hello world"); &#125;&#125; 并且Spring bean的配置（如上文所示）看起来像这样： 123456&lt;beans ...&gt; ... &lt;bean id="printer" class="org.activiti.examples.spring.Printer" /&gt;&lt;/beans&gt; 资源的自动部署Spring的集成也有一个专门用于对资源部署的特性。在流程引擎的配置中，你可以指定一组资源。当流程引擎被创建的时候， 所有在这里的资源都将会被自动扫描与部署。在这里有过滤以防止资源重新部署，只有当这个资源真正发生改变的时候，它才会向Activiti使用的数据库创建新的部署。 这对于很多用例来说，当Spring容器经常重启的情况下（例如 测试），使用它是非常不错的选择。 这里有一个例子： 12345678&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; ... &lt;property name="deploymentResources" value="classpath*:/org/activiti/spring/test/autodeployment/autodeploy.*.bpmn20.xml" /&gt;&lt;/bean&gt;&lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration" /&gt;&lt;/bean&gt; 默认，上面的配置会把所有匹配的资源发布到Activiti引擎的一个单独发布包下。用来检测防止未修改资源重复发布的机制会作用到整个发布包中。 有时候，这可能不是你想要的。比如，如果你发布了很多流程资源，但是只修改里其中某一个单独的流程定义， 整个发布包都会被认为变更了，导致整个发布包下的所有流程定义都会被重新发布， 结果就是每个流程定义都生成了新版本，虽然其中只有一个流程发生了改变。 为了定制发布方式，你可以为SpringProcessEngineConfiguration指定一个额外的参数deploymentMode。这个参数指定了匹配多个资源时的发布处理方式。默认下这个参数支持设置三个值： default: 把所有资源放在一个单独的发布包中，对这个发布包进行重复检测。 这是默认值，如果你没有指定参数值，就会使用它。 single-resource: 为每个单独的资源创建一个发布包，并对这些发布包进行重复检测。 你可以单独发布每个流程定义，并在修改流程定义后只创建一个新的流程定义版本。 resource-parent-folder: 把放在同一个上级目录下的资源发布在一个单独的发布包中，并对发布包进行重复检测。 当需要多资源需要创建发布包，但是需要根据共同的文件夹来组合一些资源时，可以使用它。 这儿有一个例子来演示将deploymentMode参数配置为single-resource的情况： 12345&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; ... &lt;property name="deploymentResources" value="classpath*:/activiti/*.bpmn" /&gt; &lt;property name="deploymentMode" value="single-resource" /&gt;&lt;/bean&gt; 如果想使用上面三个值之外的参数值，你需要自定义处理发布包的行为。 你可以创建一个SpringProcessEngineConfiguration的子类，重写getAutoDeploymentStrategy(String deploymentMode)方法。 这个方法中处理了对应deploymentMode的发布策略。 单元测试当集成Spring时，使用标准的Activiti测试工具类是非常容易的对业务流程进行测试。 下面的例子展示了如何在一个典型的基于Spring单元测试测试业务流程： 1234567891011121314151617181920212223242526@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:org/activiti/spring/test/junit4/springTypicalUsageTest-context.xml")public class MyBusinessProcessTest &#123; @Autowired private RuntimeService runtimeService; @Autowired private TaskService taskService; @Autowired @Rule public ActivitiRule activitiSpringRule; @Test @Deployment public void simpleProcessTest() &#123; runtimeService.startProcessInstanceByKey("simpleProcess"); Task task = taskService.createTaskQuery().singleResult(); assertEquals("My Task", task.getName()); taskService.complete(task.getId()); assertEquals(0, runtimeService.createProcessInstanceQuery().count()); &#125;&#125; 注意对于这种方式，你需要在Spring配置中（在上文的例子中它是自动注入的）定义一个org.activiti.engine.test.ActivitiRulebean 123&lt;bean id="activitiRule" class="org.activiti.engine.test.ActivitiRule"&gt; &lt;property name="processEngine" ref="processEngine" /&gt;&lt;/bean&gt; 基于注解的配置@EnableActiviti注解相对较新，未来可能会有变更。 除了基于XML的配置以外，还可以选择基于注解的方式来配置Spring环境。 这与使用XML的方法非常相似，除了要使用@Bean注解， 而且配置是使用java编写的。 它已经可以直接用于Activiti-Spring的集成了： 首先介绍（需要Spring 3.0+）的是@EnableActiviti注解。 最简单的用法如下所示： 12345@Configuration@EnableActivitipublic static class SimplestConfiguration &#123;&#125; 它会创建一个Spring环境，并对Activiti流程引擎进行如下配置： 默认的内存H2数据库，启用数据库自动升级。 一个简单的 DataSourceTransactionManager 一个默认的 SpringJobExecutor 自动扫描 processes/ 目录下的bpmn20.xml文件。 在这样一个环境里，可以直接通过注入操作Activiti引擎： 1234567891011121314151617181920@Autowiredprivate ProcessEngine processEngine;@Autowiredprivate RuntimeService runtimeService;@Autowiredprivate TaskService taskService;@Autowiredprivate HistoryService historyService;@Autowiredprivate RepositoryService repositoryService;@Autowiredprivate ManagementService managementService;@Autowiredprivate FormService formService; 当然，默认值都可以自定义。比如，如果配置了DataSource，它就会代替默认创建的数据库配置。 事务管理器，job执行器和其他组件都与之相同。 比如如下配置： 12345678910111213141516@Configuration@EnableActivitipublic static class Config &#123; @Bean public DataSource dataSource() &#123; BasicDataSource basicDataSource = new BasicDataSource(); basicDataSource.setUsername("sa"); basicDataSource.setUrl("jdbc:h2:mem:anotherDatabase"); basicDataSource.setDefaultAutoCommit(false); basicDataSource.setDriverClassName(org.h2.Driver.class.getName()); basicDataSource.setPassword(""); return basicDataSource; &#125;&#125; 其他数据库会代替默认的。 下面介绍了更加复杂的配置。注意AbstractActivitiConfigurer用法， 它暴露了流程引擎的配置，可以用来对它的细节进行详细的配置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Configuration@EnableActiviti@EnableTransactionManagement(proxyTargetClass = true)class JPAConfiguration &#123; @Bean public OpenJpaVendorAdapter openJpaVendorAdapter() &#123; OpenJpaVendorAdapter openJpaVendorAdapter = new OpenJpaVendorAdapter(); openJpaVendorAdapter.setDatabasePlatform(H2Dictionary.class.getName()); return openJpaVendorAdapter; &#125; @Bean public DataSource dataSource() &#123; BasicDataSource basicDataSource = new BasicDataSource(); basicDataSource.setUsername("sa"); basicDataSource.setUrl("jdbc:h2:mem:activiti"); basicDataSource.setDefaultAutoCommit(false); basicDataSource.setDriverClassName(org.h2.Driver.class.getName()); basicDataSource.setPassword(""); return basicDataSource; &#125; @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactoryBean( OpenJpaVendorAdapter openJpaVendorAdapter, DataSource ds) &#123; LocalContainerEntityManagerFactoryBean emf = new LocalContainerEntityManagerFactoryBean(); emf.setPersistenceXmlLocation("classpath:/org/activiti/spring/test/jpa/custom-persistence.xml"); emf.setJpaVendorAdapter(openJpaVendorAdapter); emf.setDataSource(ds); return emf; &#125; @Bean public PlatformTransactionManager jpaTransactionManager( EntityManagerFactory entityManagerFactory) &#123; return new JpaTransactionManager(entityManagerFactory); &#125; @Bean public AbstractActivitiConfigurer abstractActivitiConfigurer( final EntityManagerFactory emf, final PlatformTransactionManager transactionManager) &#123; return new AbstractActivitiConfigurer() &#123; @Override public void postProcessSpringProcessEngineConfiguration(SpringProcessEngineConfiguration engine) &#123; engine.setTransactionManager(transactionManager); engine.setJpaEntityManagerFactory(emf); engine.setJpaHandleTransaction(false); engine.setJobExecutorActivate(false); engine.setJpaCloseEntityManager(false); engine.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE); &#125; &#125;; &#125; // A random bean @Bean public LoanRequestBean loanRequestBean() &#123; return new LoanRequestBean(); &#125;&#125; JPA 和 Hibernate 4.2.x在Activiti引擎的serviceTask或listener中使用Hibernate 4.2.x JPA时，需要添加Spring ORM这个额外的依赖。 Hibernate 4.1.x及以下版本是不需要的。应该添加如下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Activiti</category>
        <category>工作流</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Activiti</tag>
        <tag>工作流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti 5.16 API 讲解]]></title>
    <url>%2F2020%2F04%2F09%2FActiviti-5-16-API-%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Chapter 4. Activiti APITable of Contents 流程引擎的API和服务异常策略使用Activiti的服务 发布流程 启动一个流程实例 完成任务 挂起，激活一个流程 更多知识 查询API表达式单元测试调试单元测试web应用中的流程引擎 流程引擎的API和服务引擎API是与Activiti打交道的最常用方式。 我们从ProcessEngine开始， 创建它的很多种方法都已经在 配置章节中有所涉及。 从ProcessEngine中，你可以获得很多囊括工作流/BPM方法的服务。 ProcessEngine和服务类都是线程安全的。 你可以在整个服务器中仅保持它们的一个引用就可以了。 123456789ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();RuntimeService runtimeService = processEngine.getRuntimeService();RepositoryService repositoryService = processEngine.getRepositoryService();TaskService taskService = processEngine.getTaskService();ManagementService managementService = processEngine.getManagementService();IdentityService identityService = processEngine.getIdentityService();HistoryService historyService = processEngine.getHistoryService();FormService formService = processEngine.getFormService(); ProcessEngines.getDefaultProcessEngine()会在第一次调用时 初始化并创建一个流程引擎，以后再调用就会返回相同的流程引擎。 使用对应的方法可以创建和关闭所有流程引擎：ProcessEngines.init() 和 ProcessEngines.destroy()。 ProcessEngines会扫描所有activiti.cfg.xml 和 activiti-context.xml 文件。 对于activiti.cfg.xml文件，流程引擎会使用Activiti的经典方式构建： ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine(). 对于activiti-context.xml文件，流程引擎会使用Spring方法构建：先创建一个Spring的环境， 然后通过环境获得流程引擎。 所有服务都是无状态的。这意味着可以在多节点集群环境下运行Activiti，每个节点都指向同一个数据库， 不用担心哪个机器实际执行前端的调用。 无论在哪里执行服务都没有问题。 RepositoryService可能是使用Activiti引擎时最先接触的服务。 它提供了管理和控制发布包和流程定义的操作。 这里不涉及太多细节，流程定义是BPMN 2.0流程的java实现。 它包含了一个流程每个环节的结构和行为。 发布包是Activiti引擎的打包单位。一个发布包可以包含多个BPMN 2.0 xml文件和其他资源。 开发者可以自由选择把任意资源包含到发布包中。 既可以把一个单独的BPMN 2.0 xml文件放到发布包里，也可以把整个流程和相关资源都放在一起。 （比如，’hr-processes’实例可以包含hr流程相关的任何资源）。 可以通过RepositoryService来部署这种发布包。 发布一个发布包，意味着把它上传到引擎中，所有流程都会在保存进数据库之前分析解析好。 从这点来说，系统知道这个发布包的存在，发布包中包含的流程就已经可以启动了。 除此之外，服务可以 查询引擎中的发布包和流程定义。 暂停或激活发布包，对应全部和特定流程定义。 暂停意味着它们不能再执行任何操作了，激活是对应的反向操作。 获得多种资源，像是包含在发布包里的文件， 或引擎自动生成的流程图。 获得流程定义的pojo版本， 可以用来通过java解析流程，而不必通过xml。 正如RepositoryService负责静态信息（比如，不会改变的数据，至少是不怎么改变的）， RuntimeService正好是完全相反的。它负责启动一个流程定义的新实例。 如上所述，流程定义定义了流程各个节点的结构和行为。 流程实例就是这样一个流程定义的实例。对每个流程定义来说，同一时间会有很多实例在执行。 RuntimeService也可以用来获取和保存流程变量。 这些数据是特定于某个流程实例的，并会被很多流程中的节点使用 （比如，一个排他网关常常使用流程变量来决定选择哪条路径继续流程）。 Runtimeservice也能查询流程实例和执行。 执行对应BPMN 2.0中的’token’。基本上执行指向流程实例当前在哪里。 最后，RuntimeService可以在流程实例等待外部触发时使用，这时可以用来继续流程实例。 流程实例可以有很多暂停状态，而服务提供了多种方法来’触发’实例， 接受外部触发后，流程实例就会继续向下执行。 任务是由系统中真实人员执行的，它是Activiti这类BPMN引擎的核心功能之一。 所有与任务有关的功能都包含在TaskService中： 查询分配给用户或组的任务 创建独立运行任务。这些任务与流程实例无关。 手工设置任务的执行者，或者这些用户通过何种方式与任务关联。 认领并完成一个任务。认领意味着一个人期望成为任务的执行者， 即这个用户会完成这个任务。完成意味着“做这个任务要求的事情”。 通常来说会有很多种处理形式。 IdentityService非常简单。它可以管理（创建，更新，删除，查询…）群组和用户。 请注意， Activiti执行时并没有对用户进行检查。 例如，任务可以分配给任何人，但是引擎不会校验系统中是否存在这个用户。 这是Activiti引擎也可以使用外部服务，比如ldap，活动目录，等等。 FormService是一个可选服务。即使不使用它，Activiti也可以完美运行， 不会损失任何功能。这个服务提供了启动表单和任务表单两个概念。 启动表单会在流程实例启动之前展示给用户， 任务表单会在用户完成任务时展示。Activiti支持在BPMN 2.0流程定义中设置这些表单。 这个服务以一种简单的方式将数据暴露出来。再次重申，它是可选的， 表单也不一定要嵌入到流程定义中。 HistoryService提供了Activiti引擎手机的所有历史数据。 在执行流程时，引擎会保存很多数据（根据配置），比如流程实例启动时间，任务的参与者， 完成任务的时间，每个流程实例的执行路径，等等。 这个服务主要通过查询功能来获得这些数据。 ManagementService在使用Activiti的定制环境中基本上不会用到。 它可以查询数据库的表和表的元数据。另外，它提供了查询和管理异步操作的功能。 Activiti的异步操作用途很多，比如定时器，异步操作， 延迟暂停、激活，等等。后续，会讨论这些功能的更多细节。 异常策略Activiti中的基础异常为org.activiti.engine.ActivitiException，一个非检查异常。 这个异常可以在任何时候被API抛出，不过特定方法抛出的“特定”的异常都记录在 javadocs中。 例如，下面的TaskService： 123456/** * Called when the task is successfully executed. * @param taskId the id of the task to complete, cannot be null. * @throws ActivitiObjectNotFoundException when no task exists with the given id. */ void complete(String taskId); 在上面的例子中，当传入一个不存在的任务的id时，就会抛出异常。 同时，javadoc明确指出taskId不能为null，如果传入null， 就会抛出ActivitiIllegalArgumentException。 我们希望避免过多的异常继承，下面的子类用于特定的场合。 流程引擎和API调用的其他场合不会使用下面的异常， 它们会抛出一个普通的ActivitiExceptions。 ActivitiWrongDbException：当Activiti引擎发现数据库版本号和引擎版本号不一致时抛出。 ActivitiOptimisticLockingException：对同一数据进行并发方法并出现乐观锁时抛出。 ActivitiClassLoadingException：当无法找到需要加载的类或在加载类时出现了错误（比如，JavaDelegate，TaskListener等。 ActivitiObjectNotFoundException：当请求或操作的对应不存在时抛出。 ActivitiIllegalArgumentException：这个异常表示调用Activiti API时传入了一个非法的参数，可能是引擎配置中的非法值，或提供了一个非法值，或流程定义中使用的非法值。 ActivitiTaskAlreadyClaimedException：当任务已经被认领了，再调用taskService.claim(…)就会抛出。 使用Activiti的服务像上面介绍的那样，要想操作Activiti引擎，需要通过 org.activiti.engine.ProcessEngine实例暴露的服务。 下面的代码假设你已经拥有了一个可以运行的Activiti环境。 你就可以操作一个org.activiti.engine.ProcessEngine。 如果只想简单尝试一下代码， 可以下载或者cloneActiviti单元测试模板， 导入到IDE中，把testUserguideCode()方法添加到 org.activiti.MyUnitTest中。 这个小例子的最终目标是做一个工作业务流程， 演示公司中简单的请假申请： 发布流程任何与“静态”资源有关的数据（比如流程定义）都可以通过 RepositoryService访问。 从概念上讲，所以静态数据都是Activiti的资源内容。 在src/test/resources/org/activiti/test目录下创建一个新的xml文件 VacationRequest.bpmn20.xml（如果不使用单元测试模板，你也可以在任何地方创建）， 内容如下。注意这一章不会解释例子中使用的xml结构。 如果有需要可以先阅读bpmn 2.0章来了解这些。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;definitions id="definitions" targetNamespace="http://activiti.org/bpmn20" xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn"&gt; &lt;process id="vacationRequest" name="Vacation request"&gt; &lt;startEvent id="request" activiti:initiator="employeeName"&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="numberOfDays" name="Number of days" type="long" value="1" required="true"/&gt; &lt;activiti:formProperty id="startDate" name="First day of holiday (dd-MM-yyy)" datePattern="dd-MM-yyyy hh:mm" type="date" required="true" /&gt; &lt;activiti:formProperty id="vacationMotivation" name="Motivation" type="string" /&gt; &lt;/extensionElements&gt; &lt;/startEvent&gt; &lt;sequenceFlow id="flow1" sourceRef="request" targetRef="handleRequest" /&gt; &lt;userTask id="handleRequest" name="Handle vacation request" &gt; &lt;documentation&gt; $&#123;employeeName&#125; would like to take $&#123;numberOfDays&#125; day(s) of vacation (Motivation: $&#123;vacationMotivation&#125;). &lt;/documentation&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="vacationApproved" name="Do you approve this vacation" type="enum" required="true"&gt; &lt;activiti:value id="true" name="Approve" /&gt; &lt;activiti:value id="false" name="Reject" /&gt; &lt;/activiti:formProperty&gt; &lt;activiti:formProperty id="managerMotivation" name="Motivation" type="string" /&gt; &lt;/extensionElements&gt; &lt;potentialOwner&gt; &lt;resourceAssignmentExpression&gt; &lt;formalExpression&gt;management&lt;/formalExpression&gt; &lt;/resourceAssignmentExpression&gt; &lt;/potentialOwner&gt; &lt;/userTask&gt; &lt;sequenceFlow id="flow2" sourceRef="handleRequest" targetRef="requestApprovedDecision" /&gt; &lt;exclusiveGateway id="requestApprovedDecision" name="Request approved?" /&gt; &lt;sequenceFlow id="flow3" sourceRef="requestApprovedDecision" targetRef="sendApprovalMail"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;$&#123;vacationApproved == 'true'&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;task id="sendApprovalMail" name="Send confirmation e-mail" /&gt; &lt;sequenceFlow id="flow4" sourceRef="sendApprovalMail" targetRef="theEnd1" /&gt; &lt;endEvent id="theEnd1" /&gt; &lt;sequenceFlow id="flow5" sourceRef="requestApprovedDecision" targetRef="adjustVacationRequestTask"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;$&#123;vacationApproved == 'false'&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;userTask id="adjustVacationRequestTask" name="Adjust vacation request"&gt; &lt;documentation&gt; Your manager has disapproved your vacation request for $&#123;numberOfDays&#125; days. Reason: $&#123;managerMotivation&#125; &lt;/documentation&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="numberOfDays" name="Number of days" value="$&#123;numberOfDays&#125;" type="long" required="true"/&gt; &lt;activiti:formProperty id="startDate" name="First day of holiday (dd-MM-yyy)" value="$&#123;startDate&#125;" datePattern="dd-MM-yyyy hh:mm" type="date" required="true" /&gt; &lt;activiti:formProperty id="vacationMotivation" name="Motivation" value="$&#123;vacationMotivation&#125;" type="string" /&gt; &lt;activiti:formProperty id="resendRequest" name="Resend vacation request to manager?" type="enum" required="true"&gt; &lt;activiti:value id="true" name="Yes" /&gt; &lt;activiti:value id="false" name="No" /&gt; &lt;/activiti:formProperty&gt; &lt;/extensionElements&gt; &lt;humanPerformer&gt; &lt;resourceAssignmentExpression&gt; &lt;formalExpression&gt;$&#123;employeeName&#125;&lt;/formalExpression&gt; &lt;/resourceAssignmentExpression&gt; &lt;/humanPerformer&gt; &lt;/userTask&gt; &lt;sequenceFlow id="flow6" sourceRef="adjustVacationRequestTask" targetRef="resendRequestDecision" /&gt; &lt;exclusiveGateway id="resendRequestDecision" name="Resend request?" /&gt; &lt;sequenceFlow id="flow7" sourceRef="resendRequestDecision" targetRef="handleRequest"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;$&#123;resendRequest == 'true'&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;sequenceFlow id="flow8" sourceRef="resendRequestDecision" targetRef="theEnd2"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;$&#123;resendRequest == 'false'&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;endEvent id="theEnd2" /&gt; &lt;/process&gt;&lt;/definitions&gt; 为了让Activiti引擎知道这个流程，我们必须先进行“发布”。 发布意味着引擎会把BPMN 2.0 xml解析成可以执行的东西， “发布包”中的所有流程定义都会添加到数据库中。 这样，当引擎重启时，它依然可以获得“已发布”的流程： 1234ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();RepositoryService repositoryService = processEngine.getRepositoryService();repositoryService.createDeployment().addClasspathResource("org/activiti/test/VacationRequest.bpmn20.xml").deploy();Log.info("Number of process definitions: " + repositoryService.createProcessDefinitionQuery().count()); 可以阅读发布章来了解更多关于发布的信息。 启动一个流程实例把流程定义发布到Activiti引擎后，我们可以基于它发起新流程实例。 对每个流程定义，都可以有很多流程实例。 流程定义是“蓝图”，流程实例是它的一个运行的执行。 所有与流程运行状态相关的东西都可以通过RuntimeService获得。 有很多方法可以启动一个新流程实例。在下面的代码中，我们使用定义在流程定义xml 中的key来启动流程实例。 我们也可以在流程实例启动时添加一些流程变量，因为第一个用户任务的表达式需要这些变量。 流程变量经常会被用到，因为它们赋予来自同一个流程定义的不同流程实例的特别含义。 简单来说，流程变量是区分流程实例的关键。 12345678910Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();variables.put("employeeName", "Kermit");variables.put("numberOfDays", new Integer(4));variables.put("vacationMotivation", "I'm really tired!");RuntimeService runtimeService = processEngine.getRuntimeService();ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("vacationRequest", variables);// Verify that we started a new process instanceLog.info("Number of process instances: " + runtimeService.createProcessInstanceQuery().count()); 完成任务流程启动后，第一步就是用户任务。这是必须由系统用户处理的一个环节。 通常，用户会有一个“任务列表”，展示了所有必须由这个用户处理的任务。 下面的代码展示了对应的查询可能是怎样的： 123456// Fetch all tasks for the management groupTaskService taskService = processEngine.getTaskService();List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateGroup("management").list();for (Task task : tasks) &#123; Log.info("Task available: " + task.getName());&#125; 为了让流程实例继续运行，我们需要完成整个任务。对Activiti来说，就是需要complete任务。 下面的代码展示了如何做这件事： 123456Task task = tasks.get(0);Map&lt;String, Object&gt; taskVariables = new HashMap&lt;String, Object&gt;();taskVariables.put("vacationApproved", "false");taskVariables.put("managerMotivation", "We have a tight deadline!");taskService.complete(task.getId(), taskVariables); 流程实例会进入到下一个环节。在这里例子中， 下一环节允许员工通过表单调整原始的请假申请。员工可以重新提交请假申请， 这会使流程重新进入到第一个任务。 挂起，激活一个流程我们可以挂起一个流程定义。当挂起流程定时时， 就不能创建新流程了（会抛出一个异常）。 可以通过RepositoryService挂起一个流程： 12345678ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();RepositoryService repositoryService = processEngine.getRepositoryService();repositoryService.suspendProcessDefinitionByKey("vacationRequest");try &#123; runtimeService.startProcessInstanceByKey("vacationRequest");&#125; catch (ActivitiException e) &#123; e.printStackTrace();&#125; 要想重新激活一个流程定义，可以调用repositoryService.activateProcessDefinitionXXX方法。 也可以挂起一个流程实例。挂起时，流程不能继续执行（比如，完成任务会抛出异常）， 异步操作（比如定时器）也不会执行。 挂起流程实例可以调用 runtimeService.suspendProcessInstance方法。 激活流程实例可以调用runtimeService.activateProcessInstanceXXX方法。 更多知识上面章节中我们仅仅覆盖了Activiti功能的表层。 未来我们会继续扩展这些章节，以覆盖更多Activiti API。 当然，像其他开源项目一样，学习的最好方式 是研究代码，阅读javadoc。 查询API有两种方法可以从引擎中查询数据：查询API和原生查询。查询API提供了完全类型安全的API。 你可以为自己的查询条件添加很多条件 （所有条件都以AND组合）和精确的排序条件。下面的代码展示了一个例子： 12345List&lt;Task&gt; tasks = taskService.createTaskQuery() .taskAssignee("kermit") .processVariableValueEquals("orderId", "0815") .orderByDueDate().asc() .list(); 有时，你需要更强大的查询，比如使用OR条件或不能使用查询API实现的条件。 这时，我们推荐原生查询，它让你可以编写自己的SQL查询。 返回类型由你使用的查询对象决定，数据会映射到正确的对象上。比如，任务，流程实例，，执行，等等。 因为查询会作用在数据库上，你必须使用数据库中定义的表名和列名；这要求了解内部数据结构， 因此使用原生查询时一定要注意。表名可以通过API获得，可以尽量减少对数据库的依赖。 123456789List&lt;Task&gt; tasks = taskService.createNativeTaskQuery() .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) + " T WHERE T.NAME_ = #&#123;taskName&#125;") .parameter("taskName", "gonzoTask") .list();long count = taskService.createNativeTaskQuery() .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) + " T1, " + managementService.getTableName(VariableInstanceEntity.class) + " V1 WHERE V1.TASK_ID_ = T1.ID_") .count(); 表达式Activiti使用UEL处理表达式。UEL即统一表达式语言，它时EE6规范的一部分（参考 EE6规范）。为了在所有运行环境都支持最新UEL的所有功能，我们使用了一个JUEL的修改版本。 表达式可以用在很多场景下，比如Java服务任务，执行监听器，任务监听器和条件流。虽然有两重表达式，值表达式和方法表达式，Activiti进行了抽象，所以两者可以同样使用在需要表达式的场景中。 Value expression：解析为值。默认，所有流程变量都可以使用。所有spring bean（spring环境中）也可以使用在表达式中。 一些实例： 12$&#123;myVar&#125;$&#123;myBean.myProperty&#125; Method expression：调用一个方法，使用或不使用参数。当调用一个无参数的方法时，记得在方法名后添加空的括号（以区分值表达式）。传递的参数可以是字符串也可以是表达式，它们会被自动解析。例子： 123$&#123;printer.print()&#125;$&#123;myBean.addNewOrder('orderName')&#125;$&#123;myBean.doSomething(myVar, execution)&#125; 注意这些表达式支持解析原始类型（包括比较），bean，list，数组和map。 在所有流程实例中，表达式中还可以使用一些默认对象： execution：DelegateExecution提供外出执行的额外信息。 task：DelegateTask提供当前任务的额外信息。注意，只对任务监听器的表达式有效。 authenticatedUserId：当前登录的用户id。如果没有用户登录，这个变量就不可用。 想要更多具体的使用方式和例子，参考spring中的表达式，Java服务任务，执行监听器，任务监听器或条件流。 单元测试业务流程是软件项目的一部分，它也应该和普通的业务流程一样进行测试： 使用单元测试。 因为Activiti是一个嵌入式的java引擎， 为业务流程编写单元测试和写普通单元测试完全一样。 Activiti支持JUnit 3和4进行单元测试。使用JUnit 3时， 必须集成org.activiti.engine.test.ActivitiTestCase。 它通过保护的成员变量提供ProcessEngine和服务， 在测试的setup()中， 默认会使用classpath下的activiti.cfg.xml初始化流程引擎。 想使用不同的配置文件，可以重写getConfigurationResource()方法。 如果配置文件相同的话，对应的流程引擎会被静态缓存， 就可以用于多个单元测试。 继承了ActivitiTestCase你，可以在测试方法上使用 org.activiti.engine.test.Deployment注解。 测试执行前，与测试类在同一个包下的， 格式为testClassName.testMethod.bpmn20.xml的资源文件，会被部署。 测试结束后，发布包也会被删除，包括所有相关的流程实例，任务，等等。 Deployment注解也可以直接设置资源的位置。 参考Javadocs获得更多信息。 把这些放在一起，JUnit 3测试看起来像这样。 12345678910111213public class MyBusinessProcessTest extends ActivitiTestCase &#123; @Deployment public void testSimpleProcess() &#123; runtimeService.startProcessInstanceByKey("simpleProcess"); Task task = taskService.createTaskQuery().singleResult(); assertEquals("My Task", task.getName()); taskService.complete(task.getId()); assertEquals(0, runtimeService.createProcessInstanceQuery().count()); &#125;&#125; 要想在使用JUnit 4编写单元测试时获得同样的功能， 可以使用org.activiti.engine.test.ActivitiRule。 通过它，可以通过getter方法获得流程引擎和各种服务。 和 ActivitiTestCase一样（参考上面章节），使用这个Rule 也会启用org.activiti.engine.test.Deployment注解（参考上面章节使用和配置的介绍）， 它会在classpath下查找默认的配置文件。 如果配置文件相同的话，对应的流程引擎会被静态缓存， 就可以用于多个单元测试。 下面的代码演示了JUnit 4单元测试并使用了ActivitiRule的例子。 12345678910111213141516171819public class MyBusinessProcessTest &#123; @Rule public ActivitiRule activitiRule = new ActivitiRule(); @Test @Deployment public void ruleUsageExample() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); runtimeService.startProcessInstanceByKey("ruleUsage"); TaskService taskService = activitiRule.getTaskService(); Task task = taskService.createTaskQuery().singleResult(); assertEquals("My Task", task.getName()); taskService.complete(task.getId()); assertEquals(0, runtimeService.createProcessInstanceQuery().count()); &#125;&#125; 调试单元测试当使用内存数据库H2进行单元测试时，下面的教程会告诉我们 如何在调试环境下更容易的监视Activiti的数据库。 这里的截图都是基于eclipse，这种机制很容易复用到其他IDE下。 假设我们已经在单元测试里设置了一个断点。 Ecilpse里，在代码左侧双击： 现在用调试模式运行单元测试（右击单元测试， 选择“运行为”和“单元测试”），测试会停在我们的断点上， 然后我们就可以监视测试的变量，它们显示在右侧面板里。 要监视Activiti的数据，打开“显示”窗口 （如果找不到，打开“窗口”-&gt;“显示视图”-&gt;“其他”，选择显示。） 并点击（代码已完成）org.h2.tools.Server.createWebServer(“-web”).start() 选择你点击的行，右击。然后选择“显示”（或者直接快捷方式就不用右击了） 现在打开一个浏览器，打开http://localhost:8082， 输入内存数据库的JDBC URL（默认为jdbc:h2:mem:activiti）， 点击连接按钮。 你也可以看到Activiti的数据，通过它们可以了解单元测试时如何以及为什么这样运行的。 web应用中的流程引擎ProcessEngine是线程安全的， 可以在多线程下共享。在web应用中， 意味着可以在容器启动时创建流程引擎， 在容器关闭时关闭流程引擎。 下面代码演示了如何编写一个ServletContextListener 在普通的Servlet环境下初始化和销毁流程引擎： 1234567891011public class ProcessEnginesServletContextListener implements ServletContextListener &#123; public void contextInitialized(ServletContextEvent servletContextEvent) &#123; ProcessEngines.init(); &#125; public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; ProcessEngines.destroy(); &#125;&#125; contextInitialized方法会执行ProcessEngines.init()。 这会查找classpath下的activiti.cfg.xml文件， 根据配置文件创建一个ProcessEngine（比如，多个jar中都包含配置文件）。 如果classpath中包含多个配置文件，确认它们有不同的名字。 当需要使用流程引擎时，可以通过 1ProcessEngines.getDefaultProcessEngine() 或 1ProcessEngines.getProcessEngine("myName"); 当然，也可以使用其他方式创建流程引擎， 可以参考配置章节中的描述。 ContextListener中的contextDestroyed方法会执行ProcessEngines.destroy(). 这会关闭所有初始化的流程引擎。]]></content>
      <categories>
        <category>Activiti</category>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
        <tag>工作流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti 5.16 简介 学习 配置]]></title>
    <url>%2F2020%2F04%2F09%2FActiviti-5-16-%E7%AE%80%E4%BB%8B-%E5%AD%A6%E4%B9%A0-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Activiti 5.16 用户手册Chapter 1-2-3 简介 学习 配置Table of Contents 协议下载源码必要的软件JDK 6+Eclipse Indigo 和 Juno报告问题试验性功能内部实现类 协议Activiti是基于Apache V2协议发布的。 下载http://activiti.org/download.html 源码发布包里包含大部分的已经打好jar包的源码。 如果想找到并构建完整的源码库，请参考 wiki “构建发布包”。 必要的软件JDK 6+Activiti需要运行在JDK 6或以上版本上。 进入 Oracle Java SE 下载页面 点击 “下载 JDK”按钮。页面上也提供了安装的方法。 为了验证是否安装成功，可以在命令行中执行 java -version。 它将会打印出安装的JDK的版本。 Eclipse Indigo 和 Juno（译者注：Eclipse 3.7 版本代号 Indigo 靛青， Eclipse 4.2 版本代号 Juno 朱诺）。 在Eclipse下载页面下载你选择的eclipse发布包。 解压下载文件，你就可以通过eclipse目录下的eclipse文件启动它。 此外，在该用户指南后面，专门有一章介绍安装eclipse设计器插件。 Chapter 2. 开始学习一分钟入门从Activiti网站下载Activiti Explorer的WAR文件后， 可以按照下列步骤以默认配置运行样例。 你需要一个Java 运行环境和 Apache Tomcat （其实，任何提供了servlet功能的web容器都可以正常运行。但是我们主要是使用tomcat进行的测试）。 把下载的activiti-explorer.war复制到Tomcat的webapps目录下。 执行Tomcat的bin目录下的startup.bat或startup.sh启动服务器。 Tomcat启动后，打开浏览器访问http://localhost:8080/activiti-explorer。 使用kermit/kermit登录。 这样就好了！Activiti Explorer默认使用H2内存数据库，如果你想使用其他数据库 请参考这里。 安装Activiti要安装Activiti你需要一个 Java运行环境 和 Apache Tomcat。 还要确认设置好JAVA_HOME系统变量。 不同的操作系统下的设置方法是不同的。 要运行Activiti Explorer和REST web应用，你要从Activiti的下载页下载WAR文件， 复制到Tomcat安装目录下webapps目录下。 默认Explorer应用使用的内存数据库已经包含了示例流程，用户和群组信息。 下面是示例中可以使用的用户： Table 2.1. 示例用户 账号 密码 角色kermit kermit admingonzo gonzo managerfozzie fozzie user 现在，你可以访问下列web应用： Table 2.2. webapp工具 Webapp名称 URL 描述Activiti Explorer http://localhost:8080/activiti-explorer 流程引擎的用户控制台。使用它来启动新流程，分配任务， 查看并认领任务，等等。这个工具也可以用来管理Activiti引擎。 注意Activiti Explorer演示实例只是一种简单快速展示Activiti的功能的方式。 但是并不是说只能使用这种方式使用Activiti。 Activiti只是一个jar， 可以内嵌到任何Java环境中：swing或者Tomcat, JBoss, WebSphere等等。 也可以把Activiti作为一个典型的单独运行的BPM服务器运行。 只要java可以做的，Activiti也可以。 安装Activiti数据库就像在一分钟入门里说过的，Activiti Explorer默认使用H2内存数据库。 要让Activiti使用独立运行的H2数据库或者其他数据库， 可以修改Activiti Explorer web应用WEB-INF/classes目录下的db.properties。 另外，注意Activiti Explorer自动生成了演示用的默认用户和群组，流程定义，数据模型。 要想禁用这个功能，要修改WEB-INF目录下的activiti-standalone-context.xml。 可以使用下面的demoDataGenerator bean定义代码完全禁用安装默认数据。从代码中也可以看出，我们可以单独启用或禁用每一项功能。 123456&lt;bean id="demoDataGenerator" class="org.activiti.explorer.demo.DemoDataGenerator"&gt; &lt;property name="processEngine" ref="processEngine" /&gt; &lt;property name="createDemoUsersAndGroups" value="false" /&gt; &lt;property name="createDemoProcessDefinitions" value="false" /&gt; &lt;property name="createDemoModels" value="false" /&gt;&lt;/bean&gt; 引入Activiti jar和依赖为了引用Activiti jar和依赖，我们推荐使用 Maven（或Ivy）， 它简化了我们之间的依赖管理。 参考http://www.activiti.org/community.html#maven.repository 来为你的项目引入必须的jar包。 如果不想用Maven，你也可以自己把这些jar引入到你的项目中。 Activiti下载zip包包含了一个libs目录， 包含了所有Activiti的jar包（和源代码jar包）。依赖没有用这种方式发布。 Activiti引擎必须的依赖如下所示（通过mvn dependency:tree生成）： 1234567891011org.activiti:activiti-engine:jar:5.12.1+- org.apache.commons:commons-email:jar:1.2:compile| +- javax.mail:mail:jar:1.4.1:compile| \- javax.activation:activation:jar:1.1:compile+- org.apache.commons:commons-lang3:jar:3.1:compile+- org.mybatis:mybatis:jar:3.1.1:compile+- org.springframework:spring-beans:jar:3.1.2.RELEASE:compile| \- org.springframework:spring-core:jar:3.1.2.RELEASE:compile| +- org.springframework:spring-asm:jar:3.1.2.RELEASE:compile| \- commons-logging:commons-logging:jar:1.1.1:compile\- joda-time:joda-time:jar:2.1:compile 注意：只有使用了mail service task才必须引入mail依赖jar。 所有依赖可以在Activiti 源码的模块中， 通过mvn dependency:copy-dependencies下载。 下一步使用Activiti Explorer web应用 是一个熟悉Activiti概念和功能的好办法。但是， Activiti的主要目标是为你自己的应用添加强大的BPM和工作流功能。 下面的章节会帮助你熟悉 如何在你的环境中使用Activiti进行编程： 配置章节 会教你如何设置Activiti， 如何获得ProcessEngine类的实例， 它是所有Activiti引擎功能的中心入口。 API章节会带领你了解建立Activiti API的服务。 这些服务用简便的方法提供了Activiti引擎的强大功能， 它们可以使用在任何Java环境下。 对深入了解BPMN 2.0，Activiti引擎中流程的编写结构感兴趣吗？ 请继续浏览BPMN 2.0 章节。 Chapter 3. 配置创建ProcessEngineActiviti流程引擎的配置文件是名为activiti.cfg.xml的XML文件。 注意这与使用Spring方式创建流程引擎 是不一样的。 获得ProcessEngine最简单的办法是 使用org.activiti.engine.ProcessEngines类： 1ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine() 它会在classpath下搜索activiti.cfg.xml， 并基于这个文件中的配置构建引擎。 下面代码展示了实例配置。 后面的章节会给出配置参数的详细介绍。 1234567891011121314151617181920&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="jdbcUrl" value="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000" /&gt; &lt;property name="jdbcDriver" value="org.h2.Driver" /&gt; &lt;property name="jdbcUsername" value="sa" /&gt; &lt;property name="jdbcPassword" value="" /&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;property name="jobExecutorActivate" value="false" /&gt; &lt;property name="mailServerHost" value="mail.my-corp.com" /&gt; &lt;property name="mailServerPort" value="5025" /&gt; &lt;/bean&gt;&lt;/beans&gt; 注意配置XML文件其实是一个spring的配置文件。 但不是说Activiti只能用在Spring环境中！ 我们只是利用了Spring的解析和依赖注入功能 来构建引擎。 配置文件中使用的ProcessEngineConfiguration可以通过编程方式创建。 可以配置不同的bean id（比如，第三行）。 12345ProcessEngineConfiguration.createProcessEngineConfigurationFromResourceDefault();ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource);ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource, String beanName);ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream);ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName); 也可以不使用配置文件，基于默认创建配置 （参考各种支持类） 12ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration(); 所有这些ProcessEngineConfiguration.createXXX()方法都返回 ProcessEngineConfiguration，后续可以调整成所需的对象。 在调用buildProcessEngine()后， 就会创建一个ProcessEngine： 12345ProcessEngine processEngine = ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration() .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_FALSE) .setJdbcUrl("jdbc:h2:mem:my-own-db;DB_CLOSE_DELAY=1000") .setJobExecutorActivate(true) .buildProcessEngine(); ProcessEngineConfiguration beanactiviti.cfg.xml必须包含一个id为’processEngineConfiguration’的bean。 1&lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; 这个bean会用来构建ProcessEngine。 有多个类可以用来定义processEngineConfiguration。 这些类对应不同的环境，并设置了对应的默认值。 最好选择（最）适用于你的环境的类， 这样可以少配置几个引擎的参数。 下面是目前可以使用的类（以后会包含更多）： org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration: 单独运行的流程引擎。Activiti会自己处理事务。 默认，数据库只在引擎启动时检测 （如果没有Activiti的表或者表结构不正确就会抛出异常）。 org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration: 单元测试时的辅助类。Activiti会自己控制事务。 默认使用H2内存数据库。数据库表会在引擎启动时创建，关闭时删除。 使用它时，不需要其他配置（除非使用job执行器或邮件功能）。 org.activiti.spring.SpringProcessEngineConfiguration: 在Spring环境下使用流程引擎。 参考Spring集成章节。 org.activiti.engine.impl.cfg.JtaProcessEngineConfiguration: 单独运行流程引擎，并使用JTA事务。 数据库配置Activiti可能使用两种方式配置数据库。 第一种方式是定义数据库配置参数： jdbcUrl: 数据库的JDBC URL。 jdbcDriver: 对应不同数据库类型的驱动。 jdbcUsername: 连接数据库的用户名。 jdbcPassword: 连接数据库的密码。 基于JDBC参数配置的数据库连接 会使用默认的MyBatis连接池。 下面的参数可以用来配置连接池（来自MyBatis参数）： jdbcMaxActiveConnections: 连接池中处于被使用状态的连接的最大值。默认为10。 jdbcMaxIdleConnections: 连接池中处于空闲状态的连接的最大值。 jdbcMaxCheckoutTime: 连接被取出使用的最长时间，超过时间会被强制回收。 默认为20000（20秒）。 jdbcMaxWaitTime: 这是一个底层配置，让连接池可以在长时间无法获得连接时， 打印一条日志，并重新尝试获取一个连接。（避免因为错误配置导致沉默的操作失败）。 默认为20000（20秒）。 示例数据库配置： 1234&lt;property name="jdbcUrl" value="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000" /&gt;&lt;property name="jdbcDriver" value="org.h2.Driver" /&gt;&lt;property name="jdbcUsername" value="sa" /&gt;&lt;property name="jdbcPassword" value="" /&gt; 也可以使用javax.sql.DataSource。 （比如，Apache Commons的DBCP）： 123456789101112&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" &gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/activiti" /&gt; &lt;property name="username" value="activiti" /&gt; &lt;property name="password" value="activiti" /&gt; &lt;property name="defaultAutoCommit" value="false" /&gt;&lt;/bean&gt;&lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; ... 注意，Activiti的发布包中没有这些类。 你要自己把对应的类（比如，从DBCP里）放到你的classpath下。 无论你使用JDBC还是DataSource的方式，都可以设置下面的配置： databaseType: 一般不用设置，因为可以自动通过数据库连接的元数据获取。 只有自动检测失败时才需要设置。 可能的值有：{h2, mysql, oracle, postgres, mssql, db2}。 如果没使用默认的H2数据库就必须设置这项。 这个配置会决定使用哪些创建/删除脚本和查询语句。 参考支持数据库章节 了解支持哪些类型。 databaseSchemaUpdate: 设置流程引擎启动和关闭时如何处理数据库表。 false（默认）：检查数据库表的版本和依赖库的版本， 如果版本不匹配就抛出异常。 true: 构建流程引擎时，执行检查，如果需要就执行更新。 如果表不存在，就创建。 create-drop: 构建流程引擎时创建数据库表， 关闭流程引擎时删除这些表。 JNDI数据库配置默认，Activiti的数据库配置会放在web应用的WEB-INF/classes目录下的db.properties文件中。 这样做比较繁琐， 因为要用户在每次发布时，都修改Activiti源码中的db.properties并重新编译war文件， 或者解压缩war文件，修改其中的db.properties。 使用JNDI（Java命名和目录接口）来获取数据库连接， 连接是由servlet容器管理的，可以在war部署外边管理配置。 与db.properties相比， 它也允许对连接进行更多的配置。 使用要想把Activiti Explorer和Activiti Rest应用从db.properties转换为使用 JNDI数据库配置，需要打开原始的Spring配置文件 （activiti-webapp-explorer2/src/main/webapp/WEB-INF/activiti-standalone-context.xml 和activiti-webapp-rest2/src/main/resources/activiti-context.xml）， 删除”dbProperties”和”dataSource”两个bean，然后添加如下bean： 123&lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt; &lt;property name="jndiName" value="java:comp/env/jdbc/activitiDB"/&gt;&lt;/bean&gt; 接下来，我们需要添加包含了默认的H2配置的context.xml文件。 如果已经有了JNDI配置，会覆盖这些配置。 对Activiti Explorer来说，对应的配置文件activiti-webapp-explorer2/src/main/webapp/META-INF/context.xml 如下所示： 12345678910111213141516&lt;Context antiJARLocking="true" path="/activiti-explorer2"&gt; &lt;Resource auth="Container" name="jdbc/activitiDB" type="javax.sql.DataSource" scope="Shareable" description="JDBC DataSource" url="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000" driverClassName="org.h2.Driver" username="sa" password="" defaultAutoCommit="false" initialSize="5" maxWait="5000" maxActive="120" maxIdle="5"/&gt;&lt;/Context&gt; 对于Activiti REST应用，添加的activiti-webapp-rest2/src/main/webapp/META-INF/context.xml 如下所示： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Context antiJARLocking="true" path="/activiti-rest2"&gt; &lt;Resource auth="Container" name="jdbc/activitiDB" type="javax.sql.DataSource" scope="Shareable" description="JDBC DataSource" url="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=-1" driverClassName="org.h2.Driver" username="sa" password="" defaultAutoCommit="false" initialSize="5" maxWait="5000" maxActive="120" maxIdle="5"/&gt;&lt;/Context&gt; 可选的一步，现在可以删除Activiti Explorer和Activiti Rest两个应用中 不再使用的db.properties文件了。 配置JNDI数据库配置会因为你使用的Servlet container不同而不同。 下面的配置可以在tomcat中使用，但是对其他容器， 请引用你使用的容器的文档。 如果使用tomcat，JNDI资源配置在 $CATALINA_BASE/conf/[enginename]/[hostname]/[warname].xml （对于Activiti Explorer来说，通常是在$CATALINA_BASE/conf/Catalina/localhost/activiti-explorer.war）。 当应用第一次发布时，会把这个文件从war中复制出来。 所以如果这个文件已经存在了，你需要替换它。要想修改JNDI资源让应用连接mysql而不是H2， 可以像下面这样修改： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Context antiJARLocking="true" path="/activiti-explorer2"&gt; &lt;Resource auth="Container" name="jdbc/activitiDB" type="javax.sql.DataSource" description="JDBC DataSource" url="jdbc:mysql://localhost:3306/activiti" driverClassName="com.mysql.jdbc.Driver" username="sa" password="" defaultAutoCommit="false" initialSize="5" maxWait="5000" maxActive="120" maxIdle="5"/&gt; &lt;/Context&gt; 支持的数据库下面列出Activiti使用的数据库类型（大小写敏感）。 Table 3.1. 支持的数据库 Activiti数据库类型 JDBC URL实例 备注h2 jdbc:h2:tcp://localhost/activiti 默认配置的数据库mysql jdbc:mysql://localhost:3306/activiti?autoReconnect=true 使用mysql-connector-java驱动测试oracle jdbc:oracle:thin:@localhost:1521:xepostgres jdbc:postgresql://localhost:5432/activitidb2 dbc:db2://localhost:50000/activitimssql jdbc:sqlserver://localhost:1433/activiti 创建数据库表下面是创建数据库表最简单的办法： 把activiti-engine的jar放到classpath下 添加对应的数据库驱动 把Activiti配置文件 (activiti.cfg.xml) 放到 classpath下， 指向你的数据库（参考数据库配置章节） 执行 DbSchemaCreate 类的main方法 不过，一般情况只有数据库管理员才能执行DDL语句。 在生产环境，这也是最明智的选择。 SQL DDL语句可以从Activiti下载页或Activiti发布目录里找到，在database子目录下。 脚本也包含在引擎的jar中(activiti-engine-x.jar)， 在org/activiti/db/create包下（drop目录里是删除语句）。 SQL文件的命名方式如下 1activiti.&#123;db&#125;.&#123;create|drop&#125;.&#123;type&#125;.sql 其中 db 是 支持的数据库， type 是 engine: 引擎执行的表。必须。 identity: 包含用户，群组，用户与组之间的关系的表。 这些表是可选的，只有使用引擎自带的默认身份管理时才需要。 history: 包含历史和审计信息的表。可选的：历史级别设为none时不会使用。 注意这也会引用一些需要把数据保存到历史表中的功能（比如任务的评论）。 MySQL用户需要注意： 版本低于5.6.4的MySQL不支持毫秒精度的timstamp或date类型。 更严重的是，有些版本会在尝试创建这样一列时抛出异常，而有些版本则不会。 在执行自动创建/更新时，引擎会在执行过程中修改DDL。 当使用DDL时，可以选择通用版本和名为mysql55的文件。 （它适合所有版本低于5.6.4的情况）。 后一个文件会将列的类型设置为没有毫秒的情况。 总结一下，对于MySQL版本会执行如下操作 &lt;5.6: 不支持毫秒精度。可以使用DDL文件（包含mysql55的文件）。可以实现自动创建/更新。 5.6.0 - 5.6.3: 不支持毫秒精度。无法自动创建/更新。建议更新到新的数据库版本。如果真的需要的话，也可以使用mysql 5.5。 5.6.4+:支持毫秒精度。可以使用DDL文件（默认包含mysql的文件）。可以实现自动创建、更新。 注意对于已经更新了MySQL数据库，而且Activiti表已经创建/更新的情况， 必须手工修改列的类型。 理解数据库表的命名Activiti的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。 ACT_RE_*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。 ACT_RU_*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。 ACT_ID_*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。 ACT_HI_*: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。 ACT_GE_*: 通用数据， 用于不同场景下。 数据库升级在执行更新之前要先备份数据库 （使用数据库的备份功能） 默认，每次构建流程引擎时都会进行版本检测。 这一切都在应用启动或Activiti webapp启动时发生。 如果Activiti发现数据库表的版本与依赖库的版本不同， 就会抛出异常。 要升级，你要把下面的配置 放到activiti.cfg.xml配置文件里： 123456789&lt;beans ... &gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;!-- ... --&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;!-- ... --&gt; &lt;/bean&gt;&lt;/beans&gt; 然后，把对应的数据库驱动放到classpath里。 升级应用的Activiti依赖。启动一个新版本的Activiti 指向包含旧版本的数据库。将databaseSchemaUpdate设置为true， Activiti会自动将数据库表升级到新版本， 当发现依赖和数据库表版本不通过时。 也可以执行更新升级DDL语句。 也可以执行数据库脚本，可以在Activiti下载页找到。 启用Job执行器JobExecutor是管理一系列线程的组件，可以触发定时器（也包含后续的异步消息）。 在单元测试场景下，很难使用多线程。因此API允许查询(ManagementService.createJobQuery)和执行job (ManagementService.executeJob)，所以job可以在单元测试中控制。 要避免与job执行器冲突，可以关闭它。 默认，JobExecutor在流程引擎启动时就会激活。 如果不想在流程引擎启动后自动激活JobExecutor，可以设置 1&lt;property name="jobExecutorActivate" value="false" /&gt; 配置邮件服务器可以选择配置邮件服务器。Activiti支持在业务流程中发送邮件。 想真正的发送一个email，必须配置一个真实的SMTP邮件服务器。 参考e-mail任务。 配置历史可以选择定制历史存储的配置。你可以通过配置影响引擎的历史功能。 参考历史配置。 1&lt;property name="history" value="audit" /&gt; 为表达式和脚本暴露配置默认，activiti.cfg.xml和你自己的Spring配置文件中所有bean 都可以在表达式和脚本中使用。 如果你想限制配置文件中的bean的可见性， 可以配置流程引擎配置的beans配置。 ProcessEngineConfiguration的beans是一个map。当你指定了这个参数， 只有包含这个map中的bean可以在表达式和脚本中使用。 通过在map中指定的名称来决定暴露的bean。 配置部署缓存所有流程定义都被缓存了（解析之后）避免每次使用前都要访问数据库， 因为流程定义数据是不会改变的。 默认，不会限制这个缓存。如果想限制流程定义缓存，可以添加如下配置 1&lt;property name="processDefinitionCacheLimit" value="10" /&gt; 这个配置会把默认的hashmap缓存替换成LRU缓存，来提供限制。 当然，这个配置的最佳值跟流程定义的总数有关， 实际使用中会具体使用多少流程定义也有关。 你也可以注入自己的缓存实现。这个bean必须实现 org.activiti.engine.impl.persistence.deploy.DeploymentCache接口： 123&lt;property name="processDefinitionCache"&gt; &lt;bean class="org.activiti.MyCache" /&gt;&lt;/property&gt; 有一个类似的配置叫knowledgeBaseCacheLimit和knowledgeBaseCache， 它们是配置规则缓存的。只有流程中使用规则任务时才会用到。 日志从Activiti 5.12开始，SLF4J被用作日志框架，替换了之前使用java.util.logging。 所有日志（activiti, spring, mybatis等等）都转发给SLF4J 允许使用你选择的日志实现。 默认activiti-engine依赖中没有提供SLF4J绑定的jar， 需要根据你的实际需要使用日志框架。如果没有添加任何实现jar，SLF4J会使用NOP-logger，不使用任何日志，不会发出警告，而且什么日志都不会记录。 可以通过http://www.slf4j.org/codes.html#StaticLoggerBinder了解这些实现。 使用Maven，比如使用一个依赖（这里使用log4j），注意你还需要添加一个version： 1234&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; activiti-explorer和activiti-rest应用都使用了Log4j绑定。执行所有activiti-*模块的单元测试页使用了Log4j。 特别提醒如果容器classpath中存在commons-logging： 为了把spring日志转发给SLF4J，需要使用桥接（参考http://www.slf4j.org/legacy.html#jclOverSLF4J）。 如果你的容器提供了commons-logging实现，请参考下面网页：http://www.slf4j.org/codes.html#release来确保稳定性。 使用Maven的实例（忽略版本）： 1234&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;&lt;/dependency&gt; 映射诊断上下文在5.13中，activiti支持slf4j的MDC功能。 如下的基础信息会传递到日志中记录： 流程定义Id标记为mdcProcessDefinitionID 流程实例Id标记为mdcProcessInstanceID 分支Id标记为mdcexecutionId 默认不会记录这些信息。可以配置日志使用期望的格式来显示它们，扩展通常的日志信息。 比如，下面的log4j配置定义会让日志显示上面提及的信息： 12log4j.appender.consoleAppender.layout.ConversionPattern =ProcessDefinitionId=%X&#123;mdcProcessDefinitionID&#125;executionId=%X&#123;mdcExecutionId&#125; mdcProcessInstanceID=%X&#123;mdcProcessInstanceID&#125; mdcBusinessKey=%X&#123;mdcBusinessKey&#125; %m%n" 当系统进行高风险任务，日志必须严格检查时，这个功能就非常有用，比如要使用日志分析的情况。 事件处理Activiti 5.15中实现了一种事件机制。它允许在引擎触发事件时获得提醒。 参考所有支持的事件类型了解有效的事件。 可以为对应的事件类型注册监听器，在这个类型的任何时间触发时都会收到提醒。 你可以添加引擎范围的事件监听器通过配置， 添加引擎范围的事件监听器在运行阶段使用API， 或添加event-listener到特定流程定义的BPMN XML中。 所有分发的事件，都是org.activiti.engine.delegate.event.ActivitiEvent的子类。事件包含（如果有效）type，executionId，processInstanceId和processDefinitionId。 对应的事件会包含事件发生时对应上下文的额外信息， 这些额外的载荷可以在支持的所有事件类型中找到。 事件监听器实现实现事件监听器的唯一要求是实现org.activiti.engine.delegate.event.ActivitiEventListener。下面是一个实现监听器的例子，它会把所有监听到的事件打印到标准输出中，包括job执行的事件异常： 1234567891011121314151617181920212223242526public class MyEventListener implements ActivitiEventListener &#123; @Override public void onEvent(ActivitiEvent event) &#123; switch (event.getType()) &#123; case JOB_EXECUTION_SUCCESS: System.out.println("A job well done!"); break; case JOB_EXECUTION_FAILURE: System.out.println("A job has failed..."); break; default: System.out.println("Event received: " + event.getType()); &#125; &#125; @Override public boolean isFailOnException() &#123; // The logic in the onEvent method of this listener is not critical, exceptions // can be ignored if logging fails... return false; &#125;&#125; isFailOnException()方法决定了当事件分发时，onEvent(..)方法抛出异常时的行为。 这里返回的是false，会忽略异常。 当返回true时，异常不会忽略，继续向上传播，迅速导致当前命令失败。 当事件是一个API调用的一部分时（或其他事务性操作，比如job执行）， 事务就会回滚。当事件监听器中的行为不是业务性时，建议返回false。 activiti提供了一些基础的实现，实现了事件监听器的常用场景。可以用来作为基类或监听器实现的样例： org.activiti.engine.delegate.event.BaseEntityEventListener： 这个事件监听器的基类可以用来监听实体相关的事件，可以针对某一类型实体，也可以是全部实体。 它隐藏了类型检测，并提供了三个需要重写的方法：onCreate(..), onUpdate(..) 和 onDelete(..)，当实体创建，更新，或删除时调用。对于其他实体相关的事件，会调用 onEntityEvent(..)。 配置与安装把事件监听器配置到流程引擎配置中时，会在流程引擎启动时激活，并在引擎启动启动中持续工作着。 eventListeners属性需要org.activiti.engine.delegate.event.ActivitiEventListener的队列。 通常，我们可以声明一个内部的bean定义，或使用ref引用已定义的bean。 下面的代码，向配置添加了一个事件监听器，任何事件触发时都会提醒它，无论事件是什么类型： 12345678&lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; ... &lt;property name="eventListeners"&gt; &lt;list&gt; &lt;bean class="org.activiti.engine.example.MyEventListener" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 为了监听特定类型的事件，可以使用typedEventListeners属性，它需要一个map参数。 map的key是逗号分隔的事件名（或单独的事件名）。 map的value是org.activiti.engine.delegate.event.ActivitiEventListener队列。 下面的代码演示了向配置中添加一个事件监听器，可以监听job执行成功或失败： 123456789101112&lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; ... &lt;property name="typedEventListeners"&gt; &lt;map&gt; &lt;entry key="JOB_EXECUTION_SUCCESS,JOB_EXECUTION_FAILURE" &gt; &lt;list&gt; &lt;bean class="org.activiti.engine.example.MyJobEventListener" /&gt; &lt;/list&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 分发事件的顺序是由监听器添加时的顺序决定的。首先，会调用所有普通的事件监听器（eventListeners属性），按照它们在list中的次序。然后，会调用所有对应类型的监听器（typedEventListeners属性），如果对应类型的事件被触发了。 在运行阶段添加监听器可以通过API（RuntimeService）在运行阶段添加或删除额外的事件监听器： 12345678910111213141516171819/** * Adds an event-listener which will be notified of ALL events by the dispatcher. * @param listenerToAdd the listener to add */void addEventListener(ActivitiEventListener listenerToAdd);/** * Adds an event-listener which will only be notified when an event occurs, which type is in the given types. * @param listenerToAdd the listener to add * @param types types of events the listener should be notified for */void addEventListener(ActivitiEventListener listenerToAdd, ActivitiEventType... types);/** * Removes the given listener from this dispatcher. The listener will no longer be notified, * regardless of the type(s) it was registered for in the first place. * @param listenerToRemove listener to remove */ void removeEventListener(ActivitiEventListener listenerToRemove); 注意运行期添加的监听器引擎重启后就消失了。 为流程定义添加监听器可以为特定流程定义添加监听器。监听器只会监听与这个流程定义相关的事件，以及这个流程定义上发起的所有流程实例的事件。 监听器实现可以使用，全类名定义，引用实现了监听器接口的表达式，或配置为抛出一个message/signal/error的BPMN事件。 让监听器执行用户定义的逻辑下面代码为一个流程定义添加了两个监听器。第一个监听器会接收所有类型的事件，它是通过全类名定义的。第二个监听器只接收作业成功或失败的事件，它使用了定义在流程引擎配置中的beans属性中的一个bean。 123456789&lt;process id="testEventListeners"&gt; &lt;extensionElements&gt; &lt;activiti:eventListener class="org.activiti.engine.test.MyEventListener" /&gt; &lt;activiti:eventListener delegateExpression="$&#123;testEventListener&#125;" events="JOB_EXECUTION_SUCCESS,JOB_EXECUTION_FAILURE" /&gt; &lt;/extensionElements&gt; ...&lt;/process&gt; 对于实体相关的事件，也可以设置为针对某个流程定义的监听器，实现只监听发生在某个流程定义上的某个类型实体事件。下面的代码演示了如何实现这种功能。可以用于所有实体事件（第一个例子），也可以只监听特定类型的事件（第二个例子）。 123456789&lt;process id="testEventListeners"&gt; &lt;extensionElements&gt; &lt;activiti:eventListener class="org.activiti.engine.test.MyEventListener" entityType="task" /&gt; &lt;activiti:eventListener delegateExpression="$&#123;testEventListener&#125;" events="ENTITY_CREATED" entityType="task" /&gt; &lt;/extensionElements&gt; ...&lt;/process&gt; entityType支持的值有：attachment, comment, execution,identity-link, job, process-instance, process-definition, task。 监听抛出BPMN事件另一种处理事件的方法是抛出一个BPMN事件。请注意它只针对与抛出一个activiti事件类型的BPMN事件。 比如，抛出一个BPMN事件，在流程实例删除时，会导致一个错误。 下面的代码演示了如何在流程实例中抛出一个signal，把signal抛出到外部流程（全局），在流程实例中抛出一个消息事件， 在流程实例中抛出一个错误事件。除了使用class或delegateExpression， 还使用了throwEvent属性，通过额外属性，指定了抛出事件的类型。 12345&lt;process id="testEventListeners"&gt; &lt;extensionElements&gt; &lt;activiti:eventListener throwEvent="signal" signalName="My signal" events="TASK_ASSIGNED" /&gt; &lt;/extensionElements&gt;&lt;/process&gt; 12345&lt;process id="testEventListeners"&gt; &lt;extensionElements&gt; &lt;activiti:eventListener throwEvent="globalSignal" signalName="My signal" events="TASK_ASSIGNED" /&gt; &lt;/extensionElements&gt;&lt;/process&gt; 12345&lt;process id="testEventListeners"&gt; &lt;extensionElements&gt; &lt;activiti:eventListener throwEvent="message" messageName="My message" events="TASK_ASSIGNED" /&gt; &lt;/extensionElements&gt;&lt;/process&gt; 12345&lt;process id="testEventListeners"&gt; &lt;extensionElements&gt; &lt;activiti:eventListener throwEvent="error" errorCode="123" events="TASK_ASSIGNED" /&gt; &lt;/extensionElements&gt;&lt;/process&gt; 如果需要声明额外的逻辑，是否抛出BPMN事件，可以扩展activiti提供的监听器类。在子类中重写isValidEvent(ActivitiEvent event)， 可以防止抛出BPMN事件。对应的类是org.activiti.engine.test.api.event.SignalThrowingEventListenerTest, org.activiti.engine.impl.bpmn.helper.MessageThrowingEventListener 和 org.activiti.engine.impl.bpmn.helper.ErrorThrowingEventListener. 流程定义中监听器的注意事项 事件监听器只能声明在process元素中，作为extensionElements的子元素。 监听器不能定义在流程的单个activity下。 delegateExpression中的表达式无法访问execution上下文，这与其他表达式不同（比如gateway）。 它只能引用定义在流程引擎配置的beans属性中声明的bean，或者使用spring（未使用beans属性）中所有实现了监听器接口的spring-bean。 在使用监听器的 class 属性时，只会创建一个实例。记住监听器实现不会依赖成员变量， 确认是多线程安全的。 当一个非法的事件类型用在events属性或throwEvent中时，流程定义发布时就会抛出异常。（会导致部署失败）。如果class或delegateExecution由问题（类不存在，不存在的bean引用，或代理类没有实现监听器接口），会在流程启动时抛出异常（或在第一个有效的流程定义事件被监听器接收时）。所以要保证引用的类正确的放在classpath下，表达式也要引用一个有效的实例。 通过API分发事件我们提供了通过API使用事件机制的方法，允许大家触发定义在引擎中的任何自定义事件。 建议（不强制）只触发类型为CUSTOM的ActivitiEvents。可以通过RuntimeService触发事件： 123456789/** * Dispatches the given event to any listeners that are registered. * @param event event to dispatch. * * @throws ActivitiException if an exception occurs when dispatching the event or when the &#123;@link ActivitiEventDispatcher&#125; * is disabled. * @throws ActivitiIllegalArgumentException when the given event is not suitable for dispatching. */ void dispatchEvent(ActivitiEvent event); 支持的事件类型下面是引擎中可能出现的所有事件类型。每个类型都对应org.activiti.engine.delegate.event.ActivitiEventType中的一个枚举值。 Table 3.2. 支持的事件 事件名称 描述 事件类型ENGINE_CREATED 监听器监听的流程引擎已经创建完毕，并准备好接受API调用。 org.activiti…ActivitiEventENGINE_CLOSED 监听器监听的流程引擎已经关闭，不再接受API调用。 org.activiti…ActivitiEventENTITY_CREATED 创建了一个新实体。实体包含在事件中。 org.activiti…ActivitiEntityEventENTITY_INITIALIZED 创建了一个新实体，初始化也完成了。如果这个实体的创建会包含子实体的创建，这个事件会在子实体都创建/初始化完成后被触发，这是与ENTITY_CREATED的区别。 org.activiti…ActivitiEntityEventENTITY_UPDATED 更新了已存在的实体。实体包含在事件中。 org.activiti…ActivitiEntityEventENTITY_DELETED 删除了已存在的实体。实体包含在事件中。 org.activiti…ActivitiEntityEventENTITY_SUSPENDED 暂停了已存在的实体。实体包含在事件中。会被ProcessDefinitions, ProcessInstances 和 Tasks抛出。 org.activiti…ActivitiEntityEventENTITY_ACTIVATED 激活了已存在的实体，实体包含在事件中。会被ProcessDefinitions, ProcessInstances 和 Tasks抛出。 org.activiti…ActivitiEntityEventJOB_EXECUTION_SUCCESS 作业执行成功。job包含在事件中。 org.activiti…ActivitiEntityEventJOB_EXECUTION_FAILURE 作业执行失败。作业和异常信息包含在事件中。 org.activiti…ActivitiEntityEvent and org.activiti…ActivitiExceptionEventJOB_RETRIES_DECREMENTED 因为作业执行失败，导致重试次数减少。作业包含在事件中。 org.activiti…ActivitiEntityEventTIMER_FIRED 触发了定时器。job包含在事件中。 org.activiti…ActivitiEntityEventJOB_CANCELED 取消了一个作业。事件包含取消的作业。作业可以通过API调用取消， 任务完成后对应的边界定时器也会取消，在新流程定义发布时也会取消。 org.activiti…ActivitiEntityEventACTIVITY_STARTED 一个节点开始执行 org.activiti…ActivitiActivityEventACTIVITY_COMPLETED 一个节点成功结束 org.activiti…ActivitiActivityEventACTIVITY_SIGNALED 一个节点收到了一个信号 org.activiti…ActivitiSignalEventACTIVITY_MESSAGE_RECEIVED 一个节点收到了一个消息。在节点收到消息之前触发。收到后，会触发ACTIVITY_SIGNAL或ACTIVITY_STARTED，这会根据节点的类型（边界事件，事件子流程开始事件） org.activiti…ActivitiMessageEventACTIVITY_ERROR_RECEIVED 一个节点收到了一个错误事件。在节点实际处理错误之前触发。 事件的activityId对应着处理错误的节点。 这个事件后续会是ACTIVITY_SIGNALLED或ACTIVITY_COMPLETE， 如果错误发送成功的话。 org.activiti…ActivitiErrorEventUNCAUGHT_BPMN_ERROR 抛出了未捕获的BPMN错误。流程没有提供针对这个错误的处理器。 事件的activityId为空。 org.activiti…ActivitiErrorEventACTIVITY_COMPENSATE 一个节点将要被补偿。事件包含了将要执行补偿的节点id。 org.activiti…ActivitiActivityEventVARIABLE_CREATED 创建了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。 org.activiti…ActivitiVariableEventVARIABLE_UPDATED 更新了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。 org.activiti…ActivitiVariableEventVARIABLE_DELETED 删除了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。 org.activiti…ActivitiVariableEventTASK_ASSIGNED 任务被分配给了一个人员。事件包含任务。 org.activiti…ActivitiEntityEventTASK_CREATED 创建了新任务。它位于ENTITY_CREATE事件之后。当任务是由流程创建时， 这个事件会在TaskListener执行之前被执行。 org.activiti…ActivitiEntityEventTASK_COMPLETED 任务被完成了。它会在ENTITY_DELETE事件之前触发。当任务是流程一部分时，事件会在流程继续运行之前， 后续事件将是ACTIVITY_COMPLETE，对应着完成任务的节点。 org.activiti…ActivitiEntityEventTASK_TIMEOUT 任务已超时，在TIMER_FIRED事件之后，会触发用户任务的超时事件， 当这个任务分配了一个定时器的时候。 org.activiti…ActivitiEntityEventPROCESS_COMPLETED 流程已结束。在最后一个节点的ACTIVITY_COMPLETED事件之后触发。 当流程到达的状态，没有任何后续连线时， 流程就会结束。 org.activiti…ActivitiEntityEventMEMBERSHIP_CREATED 用户被添加到一个组里。事件包含了用户和组的id。 org.activiti…ActivitiMembershipEventMEMBERSHIP_DELETED 用户被从一个组中删除。事件包含了用户和组的id。 org.activiti…ActivitiMembershipEventMEMBERSHIPS_DELETED 所有成员被从一个组中删除。在成员删除之前触发这个事件，所以他们都是可以访问的。 因为性能方面的考虑，不会为每个成员触发单独的MEMBERSHIP_DELETED事件。 org.activiti…ActivitiMembershipEvent 引擎内部所有ENTITY_*事件都是与实体相关的。下面的列表展示了实体事件与实体的对应关系： ENTITY_CREATED, ENTITY_INITIALIZED, ENTITY_DELETED: Attachment, Comment, Deployment, Execution, Group, IdentityLink, Job, Model, ProcessDefinition, ProcessInstance, Task, User. ENTITY_UPDATED: Attachment, Deployment, Execution, Group, IdentityLink, Job, Model, ProcessDefinition, ProcessInstance, Task, User. ENTITY_SUSPENDED, ENTITY_ACTIVATED: ProcessDefinition, ProcessInstance/Execution, Task. 附加信息只有同一个流程引擎中的事件会发送给对应的监听器。。的那个你有很多引擎 - 在同一个数据库运行 - 事件只会发送给注册到对应引擎的监听器。其他引擎发生的事件不会发送给这个监听器，无论实际上它们运行在同一个或不同的JVM中。 对应的事件类型（对应实体）都包含对应的实体。根据类型或事件，这些实体不能再进行更新（比如，当实例以被删除）。可能的话，使用事件提供的EngineServices来以安全的方式来操作引擎。即使如此，你需要小心的对事件对应的实体进行更新/操作。 没有对应历史的实体事件，因为它们都有运行阶段的对应实体。]]></content>
      <categories>
        <category>Activiti</category>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
        <tag>工作流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中10个常用的排序算法]]></title>
    <url>%2F2020%2F03%2F30%2FJava%E4%B8%AD10%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-1%2F</url>
    <content type="text"><![CDATA[Java中10个常用的排序算法摘要：算法在日常的编程中是非常重要的一个知识点，今天让我们一起重温排序，下面是用java实现的常用的十个算法案例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369import java.util.ArrayList;import java.util.Arrays;public class Sort &#123; public static void main(String[] args) &#123; int[] arr = new int[20]; int index = 0; for(int i = 20;i &gt; 0;i--) arr[index++] = i; System.out.println("原数组："); System.out.println(Arrays.toString(arr)); System.out.println("开始排序"); arr = InsertionSort(arr); System.out.println("排序后为："); System.out.println(Arrays.toString(arr)); &#125; // 工具：交换数组中元素的位置 public static int[] swap(int[] arr, int i, int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; &#125; // ****** 1.直接插入排序 ****** public static int[] InsertionSort(int[] arr)&#123; if(arr.length == 0 || arr.length == 1) return arr; for(int i = 0;i &lt; arr.length - 1;i++)&#123; // 将 i+1 位置的数插入 0 到 i 之间的数组，从后往前遍历 // current 指 i+1 的位置元素，pre 指 0 到 i 中依次向前遍历的指针 int current = arr[i+1]; int pre = i; while(pre &gt;= 0 &amp;&amp; current &lt; arr[pre])&#123; arr[pre+1] = arr[pre]; pre--; &#125; // 最后将原来 i+1 位置的元素放入现在 0 到 i+1 之间数组中正确的位置上 // pre+1 是因为刚才循环结束时又自减了一次 arr[pre+1] = current; // 打印这一轮的排序结果 System.out.println(Arrays.toString(arr)); &#125; return arr; &#125; // ****** 2.希尔排序 ****** // 希尔排序最重要的变量就是 gap，所有需要+1或者自加1的地方都要注意 public static int[] ShellSort(int[] arr)&#123; if(arr.length == 0 || arr.length == 1) return arr; int current, gap = arr.length / 2; while(gap &gt; 0)&#123; for(int i = gap;i &lt; arr.length;i++)&#123; // 将 pre+gap 位置的数插入 0 到 pre 之间“同组”的数组，从后往前遍历 // current 指 pre+gap 的位置元素 current = arr[i]; int pre = i - gap; while(pre &gt;= 0 &amp;&amp; arr[pre] &gt; current)&#123; arr[pre+gap] = arr[pre]; pre -= gap; &#125; arr[pre+gap] = current; // 打印这一轮的排序结果 System.out.println(Arrays.toString(arr)); &#125; gap /= 2; &#125; return arr; &#125; // ****** 3.简单选择排序 ****** public static int[] SelectionSort(int[] arr)&#123; if(arr.length == 0 || arr.length == 1) return arr; for(int i = 0;i &lt; arr.length - 1;i++)&#123; // 每一轮挑出一个最小的元素，依次与不断增长的 i 位置的元素交换 int MinIndex = i; for(int j = i;j &lt; arr.length;j++)&#123; if(arr[j] &lt; arr[MinIndex]) MinIndex = j; &#125; arr = swap(arr,MinIndex,i); // 打印这一轮的排序结果 System.out.println(Arrays.toString(arr)); &#125; return arr; &#125; // ****** 4.堆排序 ****** // 主函数 public static int[] HeapSort(int[] arr)&#123; if(arr.length == 0 || arr.length == 1) return arr; int len = arr.length; // 堆排序第一步是先把当前数组变成一个最大堆 arr = AdjustMaxHeap(arr, len-1); while(len &gt; 0)&#123; // 取出堆顶的元素（最大元素）与末尾还没有确定位置的元素交换 arr = swap(arr,0,len - 1); // 打印这一轮的排序结果 System.out.println(Arrays.toString(arr)); len--; arr = AdjustMaxHeap(arr,len - 1); &#125; return arr; &#125; // 调整为最大堆 public static int[] AdjustMaxHeap(int[] arr, int lastIndex)&#123; for(int i = (lastIndex - 1) / 2;i&gt;=0;i--)&#123; arr = AdjustLocalHeap(arr,lastIndex,i); &#125; return arr; &#125; //调整局部堆使其成为局部最大堆 /* 注意事项：堆中结点是从 1 开始的，但把数组看作堆的话，数组的下标是从 0 开始的 那么父结点与子结点的关系就会发生变化： 父结点 = （子结点-1）/2 左子结点 = 父结点*2+1 右子结点 = 父结点*2+2 */ public static int[] AdjustLocalHeap(int[] arr,int lastIndex,int i)&#123; // 找出当前结点和左右子结点（如果有左右子结点的话）中最大的元素，让这个最大的元素成为父结点 int maxIndex = i; if(i*2+1 &lt;= lastIndex &amp;&amp; arr[i] &lt; arr[i*2+1]) maxIndex = i*2+1; // 这里要多一个右子结点是否大于左子结点的判定 if(i*2+2 &lt;= lastIndex &amp;&amp; arr[i] &lt; arr[i*2+2] &amp;&amp; arr[i*2+1] &lt; arr[i*2+2]) maxIndex = i*2+2; // 如果父结点不是三个结点中的最大结点，那么将最大结点变成父结点 // 再通过递归看看这个比较小的父结点能不能再“往下沉” if(maxIndex != i)&#123; arr = swap(arr,maxIndex,i); arr = AdjustLocalHeap(arr,lastIndex,maxIndex); &#125; return arr; &#125; // ****** 5.冒泡排序 ****** public static int[] BubbleSort(int[] arr)&#123; if(arr.length == 0 || arr.length ==1) return arr; for(int i = arr.length-1;i &gt; 0;i--)&#123; for(int j = 1;j &lt;= i;j++)&#123; if(arr[j] &lt; arr[j-1]) arr = swap(arr,j,j-1); &#125; // 打印这一轮的排序结果 System.out.println(Arrays.toString(arr)); &#125; return arr; &#125; // ****** 6.快速排序 ****** //主函数 public static int[] QuickSort(int[] arr)&#123; if(arr.length == 0 || arr.length ==1) return arr; arr = LocalQuickSort(arr,0,arr.length -1 ); return arr; &#125; // 快速排序 public static int[] LocalQuickSort(int[] arr, int start, int last)&#123; if(start &gt;= last) return arr; // benchmark 指基准数，也就是这一轮将要确定位置的数 int benchmark = start; int left = start; int right = last; while(left &lt; right)&#123; // 必须右指针先走 while(arr[right] &gt; arr[benchmark] &amp;&amp; left &lt; right) right--; if(arr[right] &lt;= arr[benchmark] &amp;&amp; left &lt; right) arr[left++] = arr[right]; while(arr[left] &lt; arr[benchmark] &amp;&amp; left &lt; right) left++; if(arr[right] &gt;= arr[benchmark] &amp;&amp; left &lt; right) arr[right--] = arr[left]; &#125; arr[left] = arr[benchmark]; // 打印这一轮的排序结果 System.out.println(Arrays.toString(arr)); // 通过递归，分别对已确定位置的数的两边区域进行快速排序 arr = LocalQuickSort(arr,start,left-1); arr = LocalQuickSort(arr,left+1,last); return arr; &#125; // ****** 7.归并排序 ****** // 主函数 public static int[] MergeSort(int[] arr)&#123; if(arr.length == 0 || arr.length ==1) return arr; arr = Merge(arr,0,arr.length-1); return arr; &#125; // 归并排序 public static int[] Merge(int[] arr,int start,int last)&#123; // start &lt; last 的判断意味着 arr 指定的范围内必须至少有两个元素 if(start &lt; last)&#123; int mid = (start + last) / 2; // 左右部分分别递归 arr = Merge(arr,start,mid); arr = Merge(arr,mid+1,last); // 递归层面：从里往外依次将左半部分和右半部分整合成一个部分 arr = merge(arr,start,mid,last); &#125; return arr; &#125; public static int[] merge(int[] arr,int start,int mid,int last)&#123; // tempArr 指一个额外数组，用来临时给 arr 中同一区域的元素排序 int[] tempArr = new int[arr.length]; // p1 指 arr 指定区域的左半部分的指针，p2 指 arr 指定区域的右半部分的指针，p 指额外数组 tempArr 的指针 int p1 = start, p2 = mid+1, p = start; // 从指定区域的左右半部分中取出最小元素放入额外数组，完成指定区域内的排序 while(p1 &lt;= mid &amp;&amp; p2 &lt;= last)&#123; if(arr[p1] &lt;= arr[p2]) tempArr[p++] = arr[p1++]; else tempArr[p++] = arr[p2++]; &#125; while(p1 &lt;= mid) tempArr[p++] = arr[p1++]; while(p2 &lt;= last) tempArr[p++] = arr[p2++]; // 将额外数组中的数据覆盖到原 arr 数组中 for(int i = start;i &lt;= last;i++) arr[i] = tempArr[i]; System.out.println(Arrays.toString(arr)); return arr; &#125; // ****** 8.基数排序 ****** public static int[] RadixSort(int[] arr)&#123; if(arr.length == 0 || arr.length ==1) return arr; // max 指数组中最大的数，maxDigit 指这个最大的数是几位数 int max = arr[0]; for(int x:arr) max = Math.max(x,max); int maxDigit = 0; while(max != 0)&#123; max /= 10; maxDigit++; &#125; // mod 用于为数组中的数取余数，div 用于把通过 mod 取的余数变成个位数 int mod = 10; int div = 1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for(int j = 0;j &lt; 10;j++)&#123; bucket.add(new ArrayList&lt;Integer&gt;()); &#125; for(int i = 0;i&lt;maxDigit;i++,mod *= 10,div *= 10)&#123; // 打印这一轮的排序结果 System.out.println(Arrays.toString(arr)); for(int j = 0;j &lt; arr.length;j++)&#123; // num 指当前元素 arr[j] 的个/十/百/千位是几 int num = (arr[j] % mod) / div; bucket.get(num).add(arr[j]); &#125; int index = 0; for(int j = 0;j &lt; 10;j++)&#123; if(bucket.get(j).size() != 0)&#123; for(int x:bucket.get(j)) arr[index++] = x; // 将桶中所有的动态数组清空，否则第二次循环开始再用到这些动态数组时里面还会有数据 bucket.get(j).clear(); &#125; &#125; &#125; return arr; &#125; // ****** 9.计数排序 ****** public static int[] CountingSort(int[] arr)&#123; if(arr.length ==0 || arr.length == 1) return arr; int min, max; min = max = arr[0]; for(int x: arr)&#123; if(x &gt; max) max = x; if(x &lt; min) min = x; &#125; // bucket 指用来存储每个元素出现次数的桶，长度为元素的范围 int[] bucket = new int[max - min +1]; // 把 bucket 用 0 填满，因为之后要累加 Arrays.fill(bucket,0); // 在 bucket 中相应的位置记录每个元素出现的次数 for(int x:arr)&#123; bucket[x - min]++; &#125; int index = 0; // 依次从 bucket 中提取元素覆盖到原来的 arr 上 for(int i =0;i&lt;bucket.length;i++)&#123; while(bucket[i] != 0)&#123; arr[index++] = i + min; bucket[i]--; &#125; &#125; return arr; &#125; // ****** 10.桶排序 ****** // 主函数 public static int[] BucketSort(int[] arr)&#123; if(arr.length == 0 || arr.length == 1) return arr; arr = Bucket(arr,5); return arr; &#125; // 桶排序 // bucketSize 指每个桶的容量，bucketCount 指桶的个数 public static int[] Bucket(int[] arr,int bucketSize)&#123; int min,max; min = max = arr[0]; for(int x:arr)&#123; if(x &gt; max) max = x; if(x &gt; min) min = x; &#125; int bucketCount = (max - min) / bucketSize +1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for(int i = 0;i &lt; bucketCount;i++) bucket.add(new ArrayList&lt;Integer&gt;()); for(int x: arr)&#123; // 遍历每个桶 for(int bucketIndex = 0;bucketIndex &lt; bucketCount;bucketIndex++)&#123; // 如果 arr 当前元素在该桶的范围内，则将该元素放入该桶内，并结束遍历每个桶的循环 if(x &gt;= min + bucketIndex*bucketSize &amp;&amp; x &lt; min + (bucketIndex+1)*bucketSize)&#123; bucket.get(bucketIndex).add(x); break; &#125; &#125; &#125; int index = 0; for(int i = 0;i &lt; bucketCount;i++)&#123; // 对每个桶使用直接插入排序，调整桶内元素的顺序 bucket.set(i,InsertionSortOfArrayList(bucket.get(i))); for(int x:bucket.get(i)) arr[index++] = x; &#125; return arr; &#125; // 针对动态数组的直接插入排序 public static ArrayList&lt;Integer&gt; InsertionSortOfArrayList(ArrayList&lt;Integer&gt; arr)&#123; if(arr.size() == 0 || arr.size() ==1) return arr; int current; int pre; for(int i = 0;i &lt; arr.size() - 1;i++)&#123; pre = i; current = arr.get(i+1); while(arr.get(pre) &gt; current &amp;&amp; pre &gt;= 0)&#123; arr.set(pre+1,arr.get(pre)); pre--; &#125; arr.set(pre+1,current); &#125; return arr; &#125;&#125;]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[显式使用线程实现异步编程]]></title>
    <url>%2F2020%2F03%2F28%2F%E6%98%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[显式使用线程实现异步编程摘要本章主要讨论如何显式的使用线程实现异步编程，这其中包含如何显式使用线程实现异步编程的缺点，如何显式实现异步编程的原理。 在Java中实现异步编程最简单的方式是：每当有异步任务要执行时，使用Thread来创建一个线程来进行异步执行。在讲解如何显式使用Thread实现异步编程前，我们先来看下在同步编程模型下，在一个线程中要做两件事情的代码是怎样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 03-28 19:15 * Created by zhaoxinguo * Version 2.0.0 */package com.mtons.mblog.javaymw;/** * @description: TODO * @author zhaoxinguo * @date 2020/3/28 19:15 */public class SyncExample &#123; public static void doSomethingA() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("---doSomethingA---"); &#125; public static void doSomethingB() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("---doSomethingB---"); &#125; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); // 1.执行任务A doSomethingA(); // 2.执行任务B doSomethingB(); System.out.println(System.currentTimeMillis() - start); &#125;&#125; 运行上面的代码会启动一个Java虚拟机进程，进程内会创建一个用户线程来执行main函数(main线程)，main线程内首先执行doSometingA方法，然后执行了doSometingB方法，那么整个过程耗时4s左右，这是因为两个方法是顺序执行的。 在Java中，Java虚拟机允许应用程序同时运行多个执行线程，所以我们可在main函数内开启一个线程来异步执行任务doSometingA，而main函数所在线程执行doSometingB，即可大大缩短整个任务处理耗时。 Java中有两种方式来显式开启一个线程进行异步处理。第一种方式是实现java.lang.Runnable接口的run方法，然后传递Runnable接口的实现类作为创建Thread时的参数，启动线程，对应这种方式的main函数代码可以修改为如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 03-28 19:15 * Created by zhaoxinguo * Version 2.0.0 */package com.mtons.mblog.javaymw;/** * @description: TODO * @author zhaoxinguo * @date 2020/3/28 19:15 */public class SyncExample &#123; public static void doSomethingA() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("---doSomethingA---"); &#125; public static void doSomethingB() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("---doSomethingB---"); &#125; public static void main(String[] args) throws InterruptedException &#123; long start = System.currentTimeMillis(); // 1.开启异步单元执行任务A Thread threadA = new Thread(() -&gt; &#123; doSomethingA(); &#125;, "threadA"); threadA.start(); // 2.执行任务B doSomethingB(); // 3.同步等待线程A运行结束 threadA.join(); System.out.println(System.currentTimeMillis() - start); &#125;&#125; 如上面代码1，我们在main函数所在线程内首先使用lambda表达式创建了一个java.lang.Runnable接口的匿名实现类，用来异步执行doSometingA任务，然后将其作为Thread的参数并启动。这时候线程A与main线程并发运行，也就是任务doSometingA与任务doSometingB并发运行，代码3则等main线程运行完doSometingB任务后同步等待线程A运行完毕。运行上面代码，这时整个过程耗时大概2s，可知使用异步编程可以大大缩短任务运行时间。 Java中第二种开启线程进行异步执行的方式是实现Thread类，并重写run方法，这种方式的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Copyright 2020. javaymw.com Studio All Right Reserved * &lt;p&gt; * Create on 03-28 19:15 * Created by zhaoxinguo * Version 2.0.0 */package com.mtons.mblog.javaymw;/** * @description: TODO * @author zhaoxinguo * @date 2020/3/28 19:15 */public class SyncExample &#123; public static void doSomethingA() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("---doSomethingA---"); &#125; public static void doSomethingB() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("---doSomethingB---"); &#125; public static void main(String[] args) throws InterruptedException &#123; long start = System.currentTimeMillis(); // 1.开启异步单元执行任务A Thread thread = new Thread("threadA") &#123; @Override public void run() &#123; try &#123; doSomethingA(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; thread.start(); // 2.执行任务B doSomethingB(); // 3.同步等待线程A运行结束 thread.join(); System.out.println(System.currentTimeMillis() - start); &#125;&#125; 上面代码1创建了Thread的匿名类的实现，并重写了run方法，然后启动了线程执行。 这里有必要提一下Java中线程是有Deamon与非Deamon之分的，默认情况下我们创建的都是非Deamon线程，线程属于什么类型的与JVM退出条件有一定的关系。在Java中，当JVM进程内不存在非Deamon的线程时JVM就退出了。那么如何创建一个Deamon线程呢？其实将调用线程的setDaemon(boolean on)方法设置为true就可以了，更多详细内可以参考《Java并发编程之美》这本书。 上面我们介绍了显式使用Thread创建异步任务的两种方式，但是上述实现方式存在几个问题： 每当执行异步任务时，会直接创建一个Thread来执行异步任务，这在生产实践中是不建议使用的，因为线程创建于销毁是有开销的，并且没有限制线程的个数，如果使用不当可能会把系统线程用尽，从而造成错误。在生产环境中一般创建一个线程池，然后使用线程池中的线程来执行异步任务，线程池中的线程是可以被复用的，这可以大大减少线程创建与销毁开销；另外线程池可以有效限制创建的线程个数。 上面使用Thread执行的异步任务并没有返回值，如果我们想异步执行一个任务，并且需要在任务执行完毕后获取任务执行结果，则上面这个方式是满足不了的，这时候就需要用到JDK中的Future了。 另外，每当需要异步执行时，我们需要显式地创建线程并启动，这是典型的命令式编程方式，增加了编程者的心智负担。我们需要的是声明式的异步编程方式，即告诉程序我们要异步执行，但是具体怎么实现异步应该对我们透明。 针对第1个问题我们可以使用线程池来解决；针对第2个问题我们可以使用Future来解决；针对第3个问题，Java中提供了很多封装良好的类库来解决，在下面章节我们会一一详细介绍。]]></content>
      <categories>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识异步编程]]></title>
    <url>%2F2020%2F03%2F28%2F%E8%AE%A4%E8%AF%86%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[认识异步编程本章主要介绍异步编程的概念和作用，Java中异步编程的场景以及不同异步编程场景应使用什么技术实现。 1.1 异步编程概念与作用通常Java开发人员喜欢使用同步代码编写程序，因为这种请求(request)/响应(response)的方式比较简单，并且比较符合编程人员的的思维习惯；这种做法很好，直到系统出现性能瓶颈。在使用同步编程方式时，由于每个线程同时只能发起一个请求并同步等待返回，所以为了提高系统性能，此时我们就需要引入更多的线程来实现并行化处理。但是多线程下对共享资源进行访问时，不可避免会引入资源争用和并发问题；另外，操作系统层面对线程的个数是有限制的，不可能通过无限制的增加线程来提供系统性能；而且，使用同步阻塞的编程方式还会浪费资源，比如发起网络IO请求时，调用线程就会处于同步阻塞等待响应结果的状态，而这时候调用线程明明可以去做其他事情，等网络IO响应结构返回后再对结构进行处理。 可见通过增加单机系统线程个数的并行编程方式并不是“灵丹妙药”。通过编写异步、非阻塞的代码，则可以使用相同的底层资源将执行切换到另一个活动任务，然后在异步处理完成后再返回到当前线程继续处理，从而提高系统性能。 异步编程是可以让程序并行运行的一种手段，其可以让程序中的一个工作单元与主应用程序线程分开独立运行，并且在工作单元运行结束后，会通知主应用程序线程它的运行结果或者失败原因。使用异步编程可以提高应用程序的性能和响应能力等。 比如当调用线程使用异步方式发起网络IO请求后，调用线程就不会同步阻塞等待响应结果，而是在内存保存请求上下文后，马上返回去做其他事情，等网络IO响应结果返回后再使用IO线程通知业务线程响应结果已经返回，由业务线程对结果进行处理。可见，异步调用方式提高了线程的利用率，让系统有更多的线程资源来处理更多的请求。 比如在移动应用程序中，在用户操作移动设备屏幕发起请求后，如果是同步等待后台服务器返回结果，则当后台服务操作非常耗时时，就会造成用户看到移动设备屏幕冻结(一直处于请求处理中)，在结果返回前，用户不能操作移动设备的其他功能，这对用户体验非常不好。而使用异步编程时，当发起请求后，调用线程会发生返回，具体返回结果会通过UI线程异步进行渲染，且在这期间用户可以使用移动设备的其他功能。 1.2 异步编程场景在日常开发中我们经常会遇到这样的情况，即需要异步处理一些事情，而不需要知道异步任务的结果。比如在调用线程里面异步打日志，为了不让日志打印阻塞调用线程，会把日志设置为异步方式。如图1-1所示的日志异步化打印，使用一个内存队列把日志打印异步化，然后使用单一消费线程异步处理内存队列中的日志事件，执行具体的日志落盘操作(本质是一个多生产单消费模型)，在这种情况下，调用线程把日志任务放入队列后会继续执行其他操作，而不再关心日志任务具体是什么时候入盘的。 图 1-1 日志异步打印 在Java中，每当我们需要执行异步任务时，可以直接开启一个线程来实现，也可以把异步任务封装为任务对象投递到线程池中来执行。在Spring框架中提供了@Async注解把一个任务异步化来进行处理，具体会在后面的章节详细讲解。 有时候我们还需要在主线程等待异步任务的执行结果，这时候Future就派上用场了。比如调用线程要等任务A执行完毕后再顺序执行任务B，并且把两者的任务结果拼接起来供前端展示使用，如果调用线程是同步调用两次任务(如图 1-2所示)，则整个过程耗时为执行任务A的耗时加上执行任务B的耗时。 图 1-2 同步调用 如果使用异步编程(如图 1-3所示)，则可以在调用线程内开启一个异步运行单元来执行任务A，开启异步运行单元后调用线程会马上返回一个Future对象(futureB)，然后调用线程本身来执行任务B，等任务B执行完毕后，调用线程可以调用futureB的get()方法获取任务A的执行结果，最好再拼接两者的结果。这时由于任务A和任务B是并行运行的，所以整个过程耗时为max(调用线程执行任务B的耗时，异步运行单元执行任务A的耗时)。 图 1-3 异步调用 可见整个过程耗时显著缩短，对于用户来说，页面响应时间缩短，用户体验会更好，其中异步单元的执行一般是由线程池中的线程执行。 使用Future确实可以获取异步任务的执行结果，但是获取其结果还是会阻塞调用线程的，并没有实现完全的异步化处理，所以在JDK8中提供了CompletableFuture来弥补其缺点。CompletableFuture类允许非阻塞方式和基于通知的方式处理结果，其通过设置回调函数方式，让主线程彻底解放出来，实现了实际意义上的异步处理。 如图 1-4 所示，使用CompletableFuture时，当异步单元返回futureB后，调用线程可以在其上调用whenComplete方法设置一个回调函数action，然后调用线程就会马上返回，等异步任务执行完毕后会使用异步线程来执行回调函数action，而无须调用线程干预。如果你对CompletableFuture不了解，没关系，后面章节我们会详细讲解，这里你只需要知道其解决了传统Future的缺陷就可以了。 图 1-4 CompletableFuture异步执行 JDK8还引入了Stream，旨在有效地处理数据流(包括原始类型)，其使用声明式编程让我们可以写出可读性、可维护性很强的代码，并且结合CompletableFuture完美地实现异步编程。但是它产生的流只能使用一次，并且缺少与实际相关的操作(例如RxJava中基于时间窗口的缓存元素)，虽然可以执行并行计算，但无法指定要使用的线程池。同时，它也没有设计用于处理延迟的操作(例如RxJava中的defer操作)，所以Reactor、RxJava等Reactive API就是为了解决这些问题而生的。 Reactor、RxJava等反应式API也提供Java 8 Stream 的运算符，但它们更适用于流序列(不仅仅是集合)，并且允许定义一个转换操作的管道，该管道将应用于通过它的数据(这要归功于方便的流畅API和Lambda表达式的使用)。Reactive旨在处理同步或异步操作，并允许你对元素进行缓存(buffer)、合并(merge)、连接(join)等各种转换。 上面我们讲解了但JVM内的异步编程，那么对于跨网络的交互是否也存在异步编程范畴呢？对于网络请求来说，同步调用是比较直截了当的。比如我们在一个线程A中通过RPC请求获取服务B和服务C的数据，然后基于两者的结果做一些事情。在同步调用情况下，线程A需要调用服务B，然后同步等待服务B结果返回后，才可以对服务C发起调用，等服务C结果返回后才可以结合服务B和C的结果执行其他操作。 如图 1-5所示，线程A同步获取服务B的结果后，再同步调用服务C获取结果，可见在同步调用情况下业务执行语义比较清晰，线程A顺序地对多个服务请求进行调用；但是同步调用意味着当前发起请求的调用线程在远端机器返回结果前必须阻塞等待，这明细很浪费资源。好的做法应该是在发起请求的调用线程发起请求后，注册一个回调函数，然后马上返回去执行其他操作，当远端把结果返回后再使用IO线程或者框架线程池中的线程执行回调函数。 图 1-5 同步RPC调用 那么如何实现异步调用？在Java中NIO的出现让实现上面的功能变得简单，而高性能异步、基于事件驱动的网络编程框架Netty的出现让我们从编写繁杂的Java NIO程序中解放出来，现在的RPC框架，比如Dubbo底层网络通信，就是基于Netty实现的。Netty框架将网络编程逻辑与业务逻辑处理分离开来，在内部帮我们自动处理好网络与异步处理逻辑，让我们专心写自己的业务处理逻辑，而Netty的异步非阻塞能力与CompletableFuture结合则可以轻松地实现网络请求的异步调用。 在执行RPC(远程过程调用)调用时，使用异步编程可以提高系统的性能。如图 1-6所示，在异步调用情况下，当线程A调用服务B后，会马上返回一个异步的futureB对象，然后线程A可以在futureB上设置一个回调函数；接着线程A可以继续访问服务C，也会马上返回一个futureC对象，然后线程A可以在futureC上设置一个回调函数。 图 1-6 RPC异步调用 如图 1-6 可知，在异步调用情况下，线程A可以并发地调用服务B和服务C，而不再是顺序的。由于服务B和服务C是并发运行，所以相比同步调用，线程A获取到服务B和服务C结果的时间会缩短很多(同步调用情况下的耗时为服务B和服务C返回结果耗时的，异步调用情况下函数为max(服务B耗时，服务C耗时))。另外，这里可以借助CompletableFuture的能力等两次RPC调用都异步返回结果后再执行其他操作，这时候调用流程如图 1-7所示。 图 1-7 合并RPC调用结果 如图 1-7 所示，调用线程A首先发起服务B的远程调用，会马上返回一个futureB对象，然后发起服务C的远程调用，也会马上返回一个futureC对象，最好调用线程A使用代码futureB.thenCombine(futureC,action)等futureB和futureC结果可用时执行回调函数action。这里我们只是简单概述下基于Netty的异步非阻塞能力以及CompletableFuture的可编排能力，基于这些能力，我们可以实现功能很强大的异步编程能力。在后面章节，我们会以Dubbo框架为例讲解其借助Netty的非阻塞异步API实现服务消费端的异步调用。 其实，有了CompletableFuture实现异步编程，我们可以很自然地使用适配器来实现Reactive风格的编程。当我们使用RxJava API时，只需要使用Flowable的一些函数转转CompletableFuture为Flowable对象即可，这个我们在后面章节也会讲述。 上节讲解了网络请求中RPC框架的异步请求，其实还有一类，也就是Web请求，在Web应用中Servlet占有一席之地。在Servlet3.0规范前，Servlet容器对Servlet的处理都是每个请求对应一个线程这种1:1的模式进行处理的(如果 1-8 所示)，每当收到一个请求，都会开启一个Servlet容器内的线程来进行处理，如果Servlet内处理比较耗时，则会把Servlet容器内线程使用耗尽，然后容器就不能再处理新的请求了。 图 1-8 Servlet的阻塞处理模型 Servlet 3.0 规范中则提供了异步处理的能力，让Servlet容器中的线程可以及时释放，具体Servlet业务处理逻辑是在业务自己的线程池内来处理；虽然Servlet 3.0 规范让Servlet的执行变为异步，但是其IO还是阻塞式的。IO阻塞是说在Servlet处理请求时，从ServletInputStream中读取请求体时是阻塞的，而我们想要的是当书记就绪时直接通知我们去读取就可以了，因为这可以避免占用我们自己的线程来进行阻塞读取，好在Servlet 3.1 规范提供了非阻塞IO来解决这个问题。 虽然Servlet技术栈的不断发展实现了异步处理与非阻塞IO，但是其异步是不彻底的，因为受制于Servlet规范本身，比如其规范是同步的(Filter，Servlet)或阻塞的(getParameter，getPart)。所以新的使用少量线程和较少的硬件资源来处理并发的非阻塞Web技术栈应运而生-WebFlux，其是与Servlet技术栈并行存在的一种新技术，基于JDK8函数式编程与Netty实现天然的异步、非阻塞处理，这些我们在后面的章节会具体介绍。 为了更好的实现异步编程，降低异步编程的成本，一些框架也应运而生，比如高性能线程间消息传递库Disruptor，其通过为事件(event)预先分配内存、无锁CAS算法、缓存行填充、两阶段协议提交来实现多线程并发地处理不同的元素，从而实现高性能的异步处理。比如Akka基于Actor模式实现了天然支持分布式的使用消息进行异步处理的服务；比如高性能分布式消息中间件Apache RocketMetaQ实现了应用间的异步解耦、流量肖锋。 一些新兴的语言对异步处理的支持能力让我们忍不住称赞，Go语言就是其中之一，其通过语言层面内置的goroutine与channel可以轻松实现复杂的异步处理能力。 以上就是本书要讨论的内容。 1.3 总结本章我们首先概要介绍了异步编程的概念与作用，让大家对异步编程有一个大致的了解；然后讲解了Java中异步编程的场景，让大家通过实际场景案例进一步了解异步编程是什么，以及不同异步编程场景应使用什么技术来实现。]]></content>
      <categories>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 日志系统：一条SQL更新语句是如何执行的？]]></title>
    <url>%2F2020%2F03%2F27%2F02-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[02 日志系统：一条SQL更新语句是如何执行的？ 前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。 那么，一条更新语句的执行流程又是怎样的呢？ 之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？ 我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c： 1mysql&gt; create table T(ID int primary key, c int); 如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写： 1mysql&gt; update T set c=c+1 where ID=2; 前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。 你执行语句前要先连接数据库，这是连接器的工作。 前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。 接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。 与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。 重要的日志模块：redo log不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。 如果有人要赊账或者还账的话，掌柜一般有两种做法： 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉； 另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。 在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。 这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？ 同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。 而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。 如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。 与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。 write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。 要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。 重要的日志模块：binlog前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。 我想你肯定会问，为什么会有两份日志呢？ 因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。 这两种日志有以下三点不同。 redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 redoredo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。 这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。 你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。 两阶段提交为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？ 前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做： ** 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；** 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。 好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？ 先写 redo log 后写 binlog。 假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。 先写 binlog 后写 redo log。 如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。 可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。 你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？ 其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。 简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。 小结今天，我介绍了 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog。 redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。 sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。 我还跟你介绍了与 MySQL 日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。 文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？ 你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的答案。 感谢你的阅读，也欢迎你把这篇文章分享给更多的朋友一起阅读。]]></content>
      <categories>
        <category>MySQL</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 基础架构：一条SQL查询语句是如何执行的？]]></title>
    <url>%2F2020%2F03%2F27%2F01-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[01基础架构：一条SQL查询语句是如何执行的？ 这是专栏的第一篇文章，我想来跟你聊聊 MySQL 的基础架构。我们经常说，看一个事儿千万不要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从高维度理解问题。同样，对于 MySQL 的学习也是这样。平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时： 1mysql&gt; select * from T where ID=10； 我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。 所以今天我想和你一起把 MySQL 拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程，让你对 MySQL 有更深入的理解。这样当我们碰到 MySQL 的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。 下面我给出的是 MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。 大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。 Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。 也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。 从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。 连接器第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的： 1mysql -h$ip -P$port -u$user -p 输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。 连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。 如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。 如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。 数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。 但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。 怎么解决这个问题呢？你可以考虑以下两种方案。 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。 MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样： 1mysql&gt; select SQL_CACHE * from T where ID=10； 需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。 分析器如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。 分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。 做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。 如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。 123mysql&gt; elect * from t where ID=1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1 一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。 优化器经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join: 1mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 1.既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。2.也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。 这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。 优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。 执行器MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。 123mysql&gt; select * from T where ID=10;ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T' 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：1.调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；2.调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。3.执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 至此，这个语句就执行完成了。 对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。 你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。 在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。 小结今天我给你介绍了 MySQL 的逻辑架构，希望你对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象。由于篇幅的限制，我只是用一个查询的例子将各个环节过了一遍。如果你还对每个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。 我给你留一个问题吧，如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？ 感谢你的阅读，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。]]></content>
      <categories>
        <category>MySQL</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇词 这一次，让我们一起来搞懂MySQL]]></title>
    <url>%2F2020%2F03%2F27%2F%E5%BC%80%E7%AF%87%E8%AF%8D-%E8%BF%99%E4%B8%80%E6%AC%A1%EF%BC%8C%E8%AE%A9%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%9E%E6%87%82MySQL%2F</url>
    <content type="text"><![CDATA[开篇词 | 这一次，让我们一起来搞懂MySQL 你好，我是林先生，欢迎加入我的专栏，和我一起开始 MySQL 学习之旅。我曾先后在百度和阿里任职，从事 MySQL 数据库方面的工作，一步步地从一个数据库小白成为 MySQL 内核开发人员。回想起来，从我第一次带着疑问翻 MySQL 的源码查到答案至今，已经有十个年头了。在这个过程中，走了不少弯路，但同时也收获了很多的知识和思考，希望能在这个专栏里分享给你。 记得刚开始接触 MySQL，是我在百度贴吧做权限系统的时候。我们遇到了一个奇怪的问题，一个正常 10 毫秒就能完成的 SQL 查询请求偶尔要执行 100 多毫秒才结束。当时主管问我是什么原因，我其实也搞不清楚，就上网查答案，但怎么找都找不到，又脸皮薄不想说自己不知道，只好硬着头皮翻源码。后来遇到了越来越多的问题，也是类似的情景，所以我逐步养成了通过分析源码理解原理的习惯。 当时，我自己的感觉是，即使我只是一个开发工程师，只是 MySQL 的用户，在了解了一个个系统模块的原理后，再来使用它，感觉是完全不一样的。当在代码里写下一行数据库命令的时候，我就能想到它在数据库端将怎么执行，它的性能是怎么样的，怎样写能让我的应用程序访问数据库的性能最高。进一步，哪些数据处理让数据库系统来做性能会更好，哪些数据处理在缓存里做性能会更好，我心里也会更清楚。在建表和建索引的时候，我也会更有意识地为将来的查询优化做综合考虑，比如确定是否使用递增主键、主键的列怎样选择，等等。 但随后我又有了一个新的困惑，我觉得自己了解的 MySQL 知识点是零散的，没有形成网络。于是解决完一个问题后，很容易忘记。再碰到类似的问题，我又得再翻一次代码。 所幸在阿里工作的时候，我参与了阿里云关系型数据库服务内核的开发，并且负责开发开源分支 AliSQL，让我对 MySQL 内核和源码有了更深层次的研究和理解。在服务内部客户和公有云客户的过程中，我有机会面对和解决足够多的问题，再通过手册进行系统的学习，算是比较坎坷地将 MySQL 的知识网络补了起来。 所以，在回顾这个过程的时候，我的第一个感受是，如果一开始就有一些从理论到实战的系统性指导，那该多好啊，也许我可以学习得更快些。 在xxxx团队跟我联系策划这个专栏的时候，我还是持怀疑态度的。为什么呢？现在不比当年了，犹记得十余年前，你使用 MySQL 的过程中碰到问题的话，基本上都只能到代码里去找答案，因为那时网上的资料太少了。 而近十年来，MySQL 在中国广泛普及，技术分享文章可以说是浩如烟海。所以，现在要系统地介绍一遍 MySQL 的话，恐怕里面提及的大多数知识点，都可以在社区文章中找到。那么我们做这个专栏的意义在哪里，而它又凭什么可以收费呢？ 直到收到xxxx团队的答复，我才开始对这个专栏“想做和可以做”的事情感觉清晰起来。数据库是一个综合系统，其背后是发展了几十年的数据库理论。同时，数据库系统也是一个应用系统，可能一个业务开发人员用了两三年 MySQL，还未必清楚那些自己一直在用的“最佳实践”为什么是最佳的。 于是，我希望这个专栏能够帮助这样的一些开发者：他们正在使用 MySQL，知道如何写出逻辑正确的 SQL 语句来实现业务目标，却不确定这个语句是不是最优的；他们听说了一些使用数据库的最佳实践，但是更想了解为什么这么做；他们使用的数据库偶尔会出问题，亟需了解如何更快速、更准确地定位问题，甚至自己解决问题…… 在过去的七年里，我带过十几个应届毕业生，看着他们成长，要求他们原理先行，再实践验证。几年下来，他们的成长速度都很快，其中好几个毕业没两年就成为团队的骨干力量了。我也在社招的时候面试过很多有着不错的运维实践经验和能力的候选人，但都因为对数据库原理仅有一知半解的了解，而最终遗憾地没有通过面试。 因此，我希望这个专栏能够激发开发者对数据库原理的探索欲，从而更好地理解工作中遇到的问题，更能知道背后的为什么。所以我会选那些平时使用数据库时高频出现的知识，如事务、索引、锁等内容构成专栏的主线。这些主线上是一个个的知识点。每个点就是一个概念、一个机制或者一个原理说明。在每个说明之后，我会和你讨论一个实践相关的问题。 希望能以这样的方式，让你对 MySQL 的几条主线有一个整体的认识，并且了解基本概念。在之后的实践篇中，我会引用到这些主线的知识背景，并着力说明它们是怎样指导实践的。这样，你可以从点到线，再到面，形成自己的 MySQL 知识网络。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器、CentOS7开启、关闭防火墙命令]]></title>
    <url>%2F2020%2F03%2F23%2FUntitled%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81CentOS7%E5%BC%80%E5%90%AF%E3%80%81%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[CentOS7使用的是firewall防火墙，不再是原来的iptables1：查看firewall防火墙状态 1firewall-cmd --state 或者 1systemctl status firewalld 2：打开防火墙 1systemctl start firewalld 3：关闭防火墙 1systemctl stop firewalld 4：重启防火墙 1firewall-cmd --relaod 或者 1systemctl reload firewalld 5：开机自启动防火墙 1systemctl enable firewalld 6：禁止开机启动防火墙 1systemctl disable firewalld 6：查看已打开的端口 1firewall-cmd --list-ports 7：打开端口 1firewall-cmd --permanent --zone=public --add-port=8080/tcp 其中permanent表示永久生效，public表示作用域，8080/tcp表示端口和类型 8：关闭端口 1firewall-cmd --permanent --zone=public --remove-port=8080/tcp]]></content>
      <categories>
        <category>CentOS7防火墙</category>
      </categories>
      <tags>
        <tag>阿里云服务器</tag>
        <tag>CentOS8</tag>
        <tag>防火墙开启关闭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之把格林威治时间格式转换成北京时间格式]]></title>
    <url>%2F2020%2F03%2F23%2FJava%E4%B9%8B%E6%8A%8A%E6%A0%BC%E6%9E%97%E5%A8%81%E6%B2%BB%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java之格林威治时间格式转换成北京时间格式摘要：日常工作中，我们经常会遇到这样的需要，默认的java获取的时间是格林威治格式的，需要转换成正常格式，那么可以通过下面的方式实现，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Copyright 2020. yaodouwang.com Studio All Right Reserved * &lt;p&gt; * Create on 03-23 12:45 * Created by zhaoxinguo * Version 2.0.0 */package com.mtons.mblog;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.TimeZone;/** * @description: Java之格林威治时间格式转换成北京时间格式 * @author zhaoxinguo * @date 2020/3/23 12:45 */public class DateUtils &#123; /** * 支持jdk1.6的写法&lt;br/&gt; * 解析2015-12-27T14:20:34+08:00格式类型的时间&lt;br/&gt; * 将2015-12-27T14:20:34+08:00转换成2015-12-27 14:20:34&lt;br/&gt; * @param str * @return * @throws Exception */ public static String getTimestampTimeV16(String str) throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); TimeZone tz = TimeZone.getTimeZone("Asia/Shanghai"); sdf.setTimeZone(tz); Date date = sdf.parse(str); String string = date.toString(); return string; &#125; /** * 支持jdk1.7的写法&lt;br/&gt; * 解析2015-12-27T14:20:34+08:00格式类型的时间&lt;br/&gt; * 将2015-12-27T14:20:34+08:00转换成2015-12-27 14:20:34&lt;br/&gt; * @param str * @return * @throws Exception */ public static String getTimestampTimeV17(String str) throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX"); Date date = sdf.parse(str); String string = date.toString(); return string; &#125; /** * 将1464166640(当前时间的秒)转换成：yyyy-MM-dd HH:mm:ss格式 * @param str * @return */ public static String getTimeToDay(String str)&#123; Date date = new Date(1464166640L*1000); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); return format.format(date); &#125;&#125;]]></content>
      <categories>
        <category>时间转换</category>
      </categories>
      <tags>
        <tag>时间转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据操作日志记录表设计、可以查询、恢复历史数据记录]]></title>
    <url>%2F2020%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E8%A1%A8%E8%AE%BE%E8%AE%A1%E3%80%81%E5%8F%AF%E4%BB%A5%E6%9F%A5%E8%AF%A2%E3%80%81%E6%81%A2%E5%A4%8D%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[数据操作日志记录表设计、可以查询、恢复历史数据记录 摘要：在日常开发中，我们经常会遇到这样的需求，产品希望用户对业务系统的所有操作都做日志记录，尤其是涉及到修改、删除的时候，更应该，因为用户在操作系统的过程中难免会误操作，这时候，就需要有个可以让用户一键恢复的操作了，有了这个操作，再也不用担心误操作了，下面我们看下具体的业务流程和数据库设计。 产品：首先我们看下产品的设计图，如下图：这里就可以看到，上面是操作输入框，下面是可以一键恢复的日志记录。 数据库设计：上面我们看了产品的设计图，下面我再看下具体的数据库设计结构，见下图： 看完上面的数据库设计结构图，是不是思路很清晰了呢，以上就是我对数据操作日志记录设计的见解，仅供参考。]]></content>
      <categories>
        <category>日志记录</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之线程池]]></title>
    <url>%2F2020%2F03%2F20%2FJava%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池[TOC] 线程池概述 什么是线程池 为什么使用线程池 线程池的优势 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。 创建一个线程池并提交线程任务线程池源码解析参数认识 corePoolSize : 线程池的基本大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。 runnableTaskQueue：任务对列，用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级得无限阻塞队列。 maximumPoolSize：线程池最大大小，线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。 ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。 RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。 keepAliveTime ：线程活动保持时间，线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。 TimeUnit：线程活动保持时间的单位，可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。 类中其他属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 // 线程池的控制状态:用来表示线程池的运行状态（整型的高3位）和运行的worker数量（低29位） private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 29位的偏移量 private static final int COUNT_BITS = Integer.SIZE - 3; // 最大容量（2^29 - 1） private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // runState is stored in the high-order bits // 线程运行状态，总共有5个状态，需要3位来表示（所以偏移量的29 = 32 - 3）/** * RUNNING : 接受新任务并且处理已经进入阻塞队列的任务 * SHUTDOWN ： 不接受新任务，但是处理已经进入阻塞队列的任务 * STOP : 不接受新任务，不处理已经进入阻塞队列的任务并且中断正在运行的任务 * TIDYING : 所有的任务都已经终止，workerCount为0， 线程转化为TIDYING状态并且调用terminated钩子函数 * TERMINATED: terminated钩子函数已经运行完成 **/ private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; private static final int STOP = 1 &lt;&lt; COUNT_BITS; private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 阻塞队列 private final BlockingQueue&lt;Runnable&gt; workQueue; // 可重入锁 private final ReentrantLock mainLock = new ReentrantLock(); // 存放工作线程集合 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // 终止条件 private final Condition termination = mainLock.newCondition(); // 最大线程池容量 private int largestPoolSize; // 已完成任务数量 private long completedTaskCount; // 线程工厂 private volatile ThreadFactory threadFactory; // 拒绝执行处理器 private volatile RejectedExecutionHandler handler; // 线程等待运行时间 private volatile long keepAliveTime; // 是否运行核心线程超时 private volatile boolean allowCoreThreadTimeOut; // 核心池的大小 private volatile int corePoolSize; // 最大线程池大小 private volatile int maximumPoolSize; // 默认拒绝执行处理器 private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 构造方法12345678910111213141516171819202122public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || // 核心大小不能小于0 maximumPoolSize &lt;= 0 || // 线程池的初始最大容量不能小于0 maximumPoolSize &lt; corePoolSize || // 初始最大容量不能小于核心大小 keepAliveTime &lt; 0) // keepAliveTime不能小于0 throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); // 初始化相应的域 this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 提交任务12345678910111213141516171819202122232425262728293031323334353637383940/** 进行下面三步** 1. 如果运行的线程小于corePoolSize,则尝试使用用户定义的Runnalbe对象创建一个新的线程* 调用addWorker函数会原子性的检查runState和workCount，通过返回false来防止在不应* 该添加线程时添加了线程* 2. 如果一个任务能够成功入队列，在添加一个线城时仍需要进行双重检查（因为在前一次检查后* 该线程死亡了），或者当进入到此方法时，线程池已经shutdown了，所以需要再次检查状态，* 若有必要，当停止时还需要回滚入队列操作，或者当线程池没有线程时需要创建一个新线程* 3. 如果无法入队列，那么需要增加一个新线程，如果此操作失败，那么就意味着线程池已经shut* down或者已经饱和了，所以拒绝任务*/public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); // 获取线程池控制状态 int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; // worker数量小于corePoolSize if (addWorker(command, true)) // 添加worker // 成功则返回 return; // 不成功则再次获取线程池控制状态 c = ctl.get(); &#125; // 线程池处于RUNNING状态，将用户自定义的Runnable对象添加进workQueue队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 再次检查，获取线程池控制状态 int recheck = ctl.get(); // 线程池不处于RUNNING状态，将自定义任务从workQueue队列中移除 if (! isRunning(recheck) &amp;&amp; remove(command)) // 拒绝执行命令 reject(command); else if (workerCountOf(recheck) == 0) // worker数量等于0 // 添加worker addWorker(null, false); &#125; else if (!addWorker(command, false)) // 添加worker失败 // 拒绝执行命令 reject(command);&#125; addWorker 原子性的增加workerCount。 将用户给定的任务封装成为一个worker，并将此worker添加进workers集合中。 启动worker对应的线程，并启动该线程，运行worker的run方法。 回滚worker的创建动作，即将worker从workers集合中删除，并原子性的减少workerCount。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; // 外层无限循环 // 获取线程池控制状态 int c = ctl.get(); // 获取状态 int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; // 状态大于等于SHUTDOWN，初始的ctl为RUNNING，小于SHUTDOWN ! (rs == SHUTDOWN &amp;&amp; // 状态为SHUTDOWN firstTask == null &amp;&amp; // 第一个任务为null ! workQueue.isEmpty())) // worker队列不为空 // 返回 return false; for (;;) &#123; // worker数量 int wc = workerCountOf(c); if (wc &gt;= CAPACITY || // worker数量大于等于最大容量 wc &gt;= (core ? corePoolSize : maximumPoolSize)) // worker数量大于等于核心线程池大小或者最大线程池大小 return false; if (compareAndIncrementWorkerCount(c)) // 比较并增加worker的数量 // 跳出外层循环 break retry; // 获取线程池控制状态 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) // 此次的状态与上次获取的状态不相同 // 跳过剩余部分，继续循环 continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; // worker开始标识 boolean workerStarted = false; // worker被添加标识 boolean workerAdded = false; // Worker w = null; try &#123; // 初始化worker w = new Worker(firstTask); // 获取worker对应的线程 final Thread t = w.thread; if (t != null) &#123; // 线程不为null // 线程池锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. // 线程池的运行状态 int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || // 小于SHUTDOWN (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; // 等于SHUTDOWN并且firstTask为null if (t.isAlive()) // precheck that t is startable // 线程刚添加进来，还未启动就存活 // 抛出线程状态异常 throw new IllegalThreadStateException(); // 将worker添加到worker集合 workers.add(w); // 获取worker集合的大小 int s = workers.size(); if (s &gt; largestPoolSize) // 队列大小大于largestPoolSize // 重新设置largestPoolSize largestPoolSize = s; // 设置worker已被添加标识 workerAdded = true; &#125; &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; if (workerAdded) &#123; // worker被添加 // 开始执行worker的run方法 t.start(); // 设置worker已开始标识 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) // worker没有开始 // 添加worker失败 addWorkerFailed(w); &#125; return workerStarted;&#125; 执行任务runWorker函数中会实际执行给定任务（即调用用户重写的run方法），并且当给定任务完成后，会继续从阻塞队列中取任务，直到阻塞队列为空（即任务全部完成）。在执行给定任务时，会调用钩子函数，利用钩子函数可以完成用户自定义的一些逻辑。在runWorker中会调用到getTask函数和processWorkerExit钩子函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void runWorker(Worker w) &#123; // 获取当前线程 Thread wt = Thread.currentThread(); // 获取w的firstTask Runnable task = w.firstTask; // 设置w的firstTask为null w.firstTask = null; // 释放锁（设置state为0，允许中断） w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; // 任务不为null或者阻塞队列还存在任务 // 获取锁 w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || // 线程池的运行状态至少应该高于STOP (Thread.interrupted() &amp;&amp; // 线程被中断 runStateAtLeast(ctl.get(), STOP))) &amp;&amp; // 再次检查，线程池的运行状态至少应该高于STOP !wt.isInterrupted()) // wt线程（当前线程）没有被中断 wt.interrupt(); // 中断wt线程（当前线程） try &#123; // 在执行之前调用钩子函数 beforeExecute(wt, task); Throwable thrown = null; try &#123; // 运行给定的任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; // 执行完后调用钩子函数 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; // 增加给worker完成的任务数量 w.completedTasks++; // 释放锁 w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; // 处理完成后，调用钩子函数 processWorkerExit(w, completedAbruptly); &#125;&#125; 此函数用于从workerQueue阻塞队列中获取Runnable对象，由于是阻塞队列，所以支持有限时间等待（poll）和无限时间等待（take）。在该函数中还会响应shutDown和、shutDownNow函数的操作，若检测到线程池处于SHUTDOWN或STOP状态，则会返回null，而不再返回阻塞队列中的Runnalbe对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; // 无限循环，确保操作成功 // 获取线程池控制状态 int c = ctl.get(); // 运行的状态 int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; // 大于等于SHUTDOWN（表示调用了shutDown）并且（大于等于STOP（调用了shutDownNow）或者worker阻塞队列为空） // 减少worker的数量 decrementWorkerCount(); // 返回null，不执行任务 return null; &#125; // 获取worker数量 int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 是否允许coreThread超时或者workerCount大于核心大小 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) // worker数量大于maximumPoolSize &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; // workerCount大于1或者worker阻塞队列为空（在阻塞队列不为空时，需要保证至少有一个wc） if (compareAndDecrementWorkerCount(c)) // 比较并减少workerCount // 返回null，不执行任务，该worker会退出 return null; // 跳过剩余部分，继续循环 continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : // 等待指定时间 workQueue.take(); // 一直等待，直到有元素 if (r != null) return r; // 等待指定时间后，没有获取元素，则超时 timedOut = true; &#125; catch (InterruptedException retry) &#123; // 抛出了被中断异常，重试，没有超时 timedOut = false; &#125; &#125;&#125; processWorkerExit函数是在worker退出时调用到的钩子函数，而引起worker退出的主要因素如下 阻塞队列已经为空，即没有任务可以运行了。 调用了shutDown或shutDownNow函数 此函数会根据是否中断了空闲线程来确定是否减少workerCount的值，并且将worker从workers集合中移除并且会尝试终止线程池。 123456789101112131415161718192021222324252627282930313233private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; if (completedAbruptly) // 如果被中断，则需要减少workCount // If abrupt, then workerCount wasn't adjusted decrementWorkerCount(); // 获取可重入锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; // 将worker完成的任务添加到总的完成任务中 completedTaskCount += w.completedTasks; // 从workers集合中移除该worker workers.remove(w); &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; // 尝试终止 tryTerminate(); // 获取线程池控制状态 int c = ctl.get(); if (runStateLessThan(c, STOP)) &#123; // 小于STOP的运行状态 if (!completedAbruptly) &#123; int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 &amp;&amp; ! workQueue.isEmpty()) // 允许核心超时并且workQueue阻塞队列不为空 min = 1; if (workerCountOf(c) &gt;= min) // workerCount大于等于min // 直接返回 return; // replacement not needed &#125; // 添加worker addWorker(null, false); &#125;&#125; 关闭线程池123456789101112131415161718public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 检查shutdown权限 checkShutdownAccess(); // 设置线程池控制状态为SHUTDOWN advanceRunState(SHUTDOWN); // 中断空闲worker interruptIdleWorkers(); // 调用shutdown钩子函数 onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; // 尝试终止 tryTerminate();&#125; 1234567891011121314151617181920212223242526272829303132333435363738final void tryTerminate() &#123; for (;;) &#123; // 无限循环，确保操作成功 // 获取线程池控制状态 int c = ctl.get(); if (isRunning(c) || // 线程池的运行状态为RUNNING runStateAtLeast(c, TIDYING) || // 线程池的运行状态最小要大于TIDYING (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) // 线程池的运行状态为SHUTDOWN并且workQueue队列不为null // 不能终止，直接返回 return; if (workerCountOf(c) != 0) &#123; // 线程池正在运行的worker数量不为0 // Eligible to terminate // 仅仅中断一个空闲的worker interruptIdleWorkers(ONLY_ONE); return; &#125; // 获取线程池的锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; // 比较并设置线程池控制状态为TIDYING try &#123; // 终止，钩子函数 terminated(); &#125; finally &#123; // 设置线程池控制状态为TERMINATED ctl.set(ctlOf(TERMINATED, 0)); // 释放在termination条件上等待的所有线程 termination.signalAll(); &#125; return; &#125; &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; // else retry on failed CAS &#125;&#125; 123456789101112131415161718192021222324252627private void interruptIdleWorkers(boolean onlyOne) &#123; // 线程池的锁 final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; for (Worker w : workers) &#123; // 遍历workers队列 // worker对应的线程 Thread t = w.thread; if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; // 线程未被中断并且成功获得锁 try &#123; // 中断线程 t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; // 释放锁 w.unlock(); &#125; &#125; if (onlyOne) // 若只中断一个，则跳出循环 break; &#125; &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125;&#125;]]></content>
      <categories>
        <category>线程池</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之ConcurrentHashMap源码解析]]></title>
    <url>%2F2020%2F03%2F20%2FJava%E4%B9%8BConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap源码解析[TOC] jdk8之前的实现原理jdk8的实现原理JDK8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。 变量解释 table：默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方。 nextTable：默认为null，扩容时新生成的数组，其大小为原数组的两倍。 sizeCtl ：默认为0，用来控制table的初始化和扩容操作，具体应用在后续会体现出来。 -1 代表table正在初始化 -N 表示有N-1个线程正在进行扩容操作 其余情况： 1、如果table未初始化，表示table需要初始化的大小。 2、如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n &gt;&gt;&gt; 2)）。 Node：保存key，value及key的hash值的数据结构。 ForwardingNode：一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动。 初始化实例化ConcurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小总是2的幂次方。 123456789private static final int tableSizeFor(int c) &#123; int n = c - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 初始化table1234567891011121314151617181920212223private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; //如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功，当前线程只需要让出cpu时间片 if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab; &#125; put操作123456789101112131415161718192021222324final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); // table中定位索引位置，n是table的大小 // 如果f为null，说明table中这个位置第一次插入元素，利用Unsafe.compareAndSwapObject方法插入Node节点。 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 如果CAS成功，说明Node节点已经插入，随后addCount(1L,binCout)方法会检查当前容量是否需要进行扩容。如果CAS失败，说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点。 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; // 如果f的hash值为-1，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，则一起进行扩容操作。 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); //省略部分代码 &#125; addCount(1L, binCount); return null; &#125; hash算法1static final int spread(int h) &#123;return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; 获取table中对应的元素f123static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125; Doug Lea采用Unsafe.getObjectVolatile来获取，也许有人质疑，直接table[index]不可以么，为什么要这么复杂？在java内存模型中，我们已经知道每个线程都有一个工作内存，里面存储着table的副本，虽然table是volatile修饰的，但不能保证线程每次都拿到table中的最新元素，Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。 链表或红黑树操作其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445synchronized (f) &#123; // 在节点f上进行同步，节点插入之前，再次利用tabAt(tab, i) == f判断，防止被其它线程修改。 if (tabAt(tab, i) == f) &#123; // 如果f.hash &gt;= 0，说明f是链表结构的头结点，遍历链表，如果找到对应的node节点，则修改value，否则在链表尾部加入节点。 if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; // 如果f是TreeBin类型节点，说明f是红黑树根节点，则在树结构上遍历元素，更新或增加节点。 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125;&#125;// 如果链表中节点数binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构。if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break;&#125; table 扩容当table容量不足的时候，即table的元素数量达到容量阈值sizeCtl，需要对table进行扩容。 整个扩容分为两部分： 构建一个nextTable，大小为table的两倍。 把table的数据复制到nextTable中。 这两个过程在单线程下实现很简单，但是ConcurrentHashMap是支持并发插入的，扩容操作自然也会有并发的出现，这种情况下，第二步可以支持节点的并发复制，这样性能自然提升不少，但实现的复杂度也上升了一个台阶。 先看第一步，构建nextTable，毫无疑问，这个过程只能只有单个线程进行nextTable的初始化，具体实现如下： 12345678910111213141516171819202122private final void addCount(long x, int check) &#123; // 省略部分代码 if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125; &#125; get操作12345678910111213141516171819public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) // 树 return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; // 链表 if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125;]]></content>
      <categories>
        <category>ConcurrentHashMap</category>
      </categories>
      <tags>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java计算账户余额核心类]]></title>
    <url>%2F2020%2F03%2F03%2FJava%E8%AE%A1%E7%AE%97%E8%B4%A6%E6%88%B7%E4%BD%99%E9%A2%9D%E6%A0%B8%E5%BF%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[摘要：在项目开发中，有这样一个业务场景，就是我们有个虚拟服务，服务是按一定的YD(这里的YD相当于一般的积分即可)去抵扣的，同时YD又是通过用户下单购买产生的，规则如下图：那么在用户使用服务的时候，会消费一定的YD，那么久需要计算账户的剩余YD，详细见如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206/** * Copyright 2019. yaodouwang.com Studio All Right Reserved * * Create on Nov 8, 2019 1:56:16 PM * created by yolo * Version 1.0.0 */package com.yaodou.baseproduct;import java.math.BigDecimal;import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;import com.yaodou.utils.OtherException;/** * 计算账户余额 * @author yolo * @date 2019-11-08 */public class caculatePriceUtil &#123; public static void main(String[] args) &#123; generateTotal("A1001",new BigDecimal(1000)); generateTotal("A1001",new BigDecimal(1000)); generateTotal("A1001",new BigDecimal(1000)); &#125; private static final String DEAULT_ORDER_ID = "NA"; private static final BigDecimal DEFAULT_UNIT_PRICE = new BigDecimal(0.05); /** * 根据用户编码获取当前用户账户余额 * @param userId 用户唯一标示 * @return * @author yolo * @date 2019-11-08 */ @SuppressWarnings("unchecked") private static Map&lt;String,Object&gt; generateTotal(String userId,BigDecimal todayQuantity) &#123; //如果今日消费数量为0 则不用走以下统计流程 if(todayQuantity.compareTo(BigDecimal.ZERO) == 0) &#123; return null; &#125; //返回数据形式定义 Map&lt;String,Object&gt; returnMap = new HashMap&lt;&gt;(); //--》消费记录map List&lt;YdyConsumePO&gt; consumeList = new ArrayList&lt;&gt;(); //剩余总额 BigDecimal remainTotalMoney = BigDecimal.ZERO; //TODO 根据userId去账户表ydy_account查询该用户对应的 账户account_id 余额remain_balance，剩余条数remain_quantity String accountId = "A1001"; //剩余条数，这个条数是统计后的条数 BigDecimal remainQuantity = new BigDecimal(100000); //TODO 去ydy_recharge表查询 status="N"的充值记录，时间正序排序。取出以下对应字段 List&lt;YdyRechargePO&gt; rechargeList = new LinkedList&lt;YdyRechargePO&gt;(); //如果没有可用充值记录，则直接把今日消费的条数记录成 欠费条数 if(rechargeList.size() ==0) &#123; YdyConsumePO consumer = new YdyConsumePO(); consumer.setAcountId(accountId); consumer.setConsumeQuantity(remainQuantity); consumer.setOrderId("初始化orderId"); //为空代表超前消费//欠费 consumeList.add(consumer); remainTotalMoney = remainQuantity.multiply(DEFAULT_UNIT_PRICE).negate();//取负数 &#125;else &#123; BigDecimal totalQuantity = rechargeList.get(0).getTotalQuanity(); //校准数据，如果剩余量和库存不一样则跑出异常 if(totalQuantity.compareTo(remainQuantity) != 0)&#123; throw new OtherException("数据有异常，请联系开发人员核对数据！"); &#125; //如果今日消费条数大于或者等于剩余总的条数 if(todayQuantity.compareTo(totalQuantity) !=-1) &#123; //TODO 所有的rechage表中的状态都变成 N for(YdyRechargePO recharge:rechargeList) &#123; generateConsumList(consumeList, recharge.getOrderId(), recharge.getRemainQuantity(), accountId); remainTotalMoney = BigDecimal.ZERO; &#125; //大于 if(todayQuantity.compareTo(totalQuantity) ==1) &#123; //欠费数量 BigDecimal oweQuantity = todayQuantity.divide(totalQuantity); generateConsumList(consumeList, oweQuantity, accountId); remainTotalMoney = oweQuantity.multiply(DEFAULT_UNIT_PRICE).negate(); &#125; &#125;else &#123; Map&lt;String,Object&gt; rechargeMap = getIndex(rechargeList, todayQuantity); List&lt;YdyRechargePO&gt; rechargeUpdateList= (List&lt;YdyRechargePO&gt;) rechargeMap.get("rechargeUpdateList"); BigDecimal newRemainQuantity = (BigDecimal) rechargeMap.get("newRemainQuantity"); int index = (int) rechargeMap.get("index"); YdyRechargePO updateRemaining = rechargeList.get(index); if(newRemainQuantity.compareTo(BigDecimal.ZERO)!=0) &#123; //TODO 修改updateRemaining记录 把remianQuantity设置成newRemainQuantity generateConsumList(consumeList, updateRemaining.getOrderId(), updateRemaining.getRemainQuantity().divide(newRemainQuantity), accountId); &#125; //TODO 把rechargeIdList 集合中的YdyRechargePO 记录状态都修改成N generateConsumList(consumeList, rechargeUpdateList); remainTotalMoney = (BigDecimal) rechargeMap.get("remianTotalMoney"); &#125; &#125; //返回的数据 returnMap.put("remainTotalMoney", remainTotalMoney); returnMap.put("consumerList", consumeList); return returnMap; &#125; /** * 生成消费记录 * @param consumeList * @param rechargeList * @author yolo * @date 2019-11-08 */ private static void generateConsumList(List&lt;YdyConsumePO&gt; consumeList,List&lt;YdyRechargePO&gt; rechargeList) &#123; for(YdyRechargePO recharge:rechargeList) &#123; generateConsumList(consumeList, recharge.getOrderId(), recharge.getRemainQuantity(), recharge.getAcountId()); &#125; &#125; /** * 生成消费记录 * @param consumeList 消费记录insert数据的list * @param orderId 充值编码 * @param consumeQuantity 消费数量 * @param accuntId 账户编码 * @author yolo * @date 2019-11-08 */ private static void generateConsumList(List&lt;YdyConsumePO&gt; consumeList,String orderId,BigDecimal consumeQuantity,String accountId) &#123; YdyConsumePO consumer = new YdyConsumePO(); consumer.setOrderId(orderId); consumer.setConsumeQuantity(consumeQuantity); consumer.setAcountId(accountId); consumeList.add(consumer); &#125; /** * 生成消费记录 * @param consumeList 消费记录insert数据的list * @param consumeQuantity 消费数量 * @param accountId 账户编码 * @author yolo * @date 2019-11-08 */ private static void generateConsumList(List&lt;YdyConsumePO&gt; consumeList, BigDecimal consumeQuantity,String accountId) &#123; generateConsumList(consumeList, DEAULT_ORDER_ID, consumeQuantity, accountId); &#125; /** * 计算剩余第几条记录的总条数满足扣除 * @param rechargeList 没有消费的充值记录的list * @param todayQuantity 今日消费条数 * @return * @author yolo * @date 2019-11-08 */ private static Map&lt;String,Object&gt; getIndex(List&lt;YdyRechargePO&gt; rechargeList,BigDecimal todayQuantity) &#123; BigDecimal total = BigDecimal.ZERO; int size = rechargeList.size(); List&lt;YdyRechargePO&gt; rechargeUpdateList = new ArrayList&lt;&gt;(size); //充值记录剩余未使用的条数 BigDecimal newRemainQuantity = BigDecimal.ZERO; //账余额 BigDecimal remianTotalMoney = BigDecimal.ZERO; //判断是否需要停止叠加价格 boolean isCaculateMoney = Boolean.FALSE; Map&lt;String,Object&gt; returnMap = new HashMap&lt;&gt;(); for(int i=0;i&lt; size;i++) &#123; YdyRechargePO recharge = rechargeList.get(i); total = recharge.getRemainQuantity();//剩余未使用的的数量 if(isCaculateMoney) &#123; remianTotalMoney = remianTotalMoney.add(recharge.getRechargeAmount());//充值金额 &#125;else &#123; if(total.compareTo(todayQuantity) !=-1) &#123; newRemainQuantity = total.divide(todayQuantity); remianTotalMoney = recharge.getRechargeUnitPrice().multiply(newRemainQuantity).setScale(2);//充值金额 if(newRemainQuantity.compareTo(BigDecimal.ZERO)==0) &#123; rechargeUpdateList.add(recharge); &#125; returnMap.put("index", i); isCaculateMoney = Boolean.TRUE; &#125;else &#123; rechargeUpdateList.add(recharge); total = total.add(recharge.getRemainQuantity()); &#125; &#125; &#125; returnMap.put("newRemainQuantity", newRemainQuantity); returnMap.put("rechargeUpdateList", rechargeUpdateList); returnMap.put("remianTotalMoney", remianTotalMoney); return returnMap; &#125;&#125;]]></content>
      <tags>
        <tag>账户</tag>
        <tag>余额</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对List里面的元素实现按指定字段排序的方法]]></title>
    <url>%2F2020%2F02%2F03%2FJava%E5%AF%B9List%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%83%E7%B4%A0%E5%AE%9E%E7%8E%B0%E6%8C%89%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[摘要：在日常开发中，经常会用到排序算法，这里记录下日常使用比较多的排序方法，其中包括按指定指定：正序、倒序排序，还有按自定义字段排序的方法，方便日后查看； 一：按指定字段排序，默认倒序，如下写法： 123456789101112131415/** * @description 对List集合按指定字段排序，默认倒序 * @author zhaoxinguo * @date 2019/12/26 */private void sortList(List&lt;Map&lt;String, Object&gt;&gt; platformDataStatistics) &#123; platformDataStatistics.sort(new Comparator&lt;Map&lt;String, Object&gt;&gt;() &#123; @Override public int compare(Map&lt;String, Object&gt; o1, Map&lt;String, Object&gt; o2) &#123; BigDecimal divideResult2 = (BigDecimal) o2.get("divideResult"); BigDecimal divideResult1 = (BigDecimal) o1.get("divideResult"); return divideResult2.compareTo(divideResult1); &#125; &#125;);&#125; 二：按自定义顺序排序，如下写法： 1234567891011121314151617181920/** * @description 自定义排序规则，默认：京东、天猫、拼多多 * @author zhaoxinguo * @date 2020/2/3 */private void customSortList(List&lt;Map&lt;String, Object&gt;&gt; platformDataStatistics) &#123; //这里的顺序，是我自己定义的一个List&lt;String&gt; String[] regulation = &#123;"京东","天猫","拼多多"&#125;; final List&lt;String&gt; regulationOrder = Arrays.asList(regulation); Collections.sort(platformDataStatistics, new Comparator&lt;Map&lt;String, Object&gt;&gt;() &#123; @Override public int compare(Map&lt;String, Object&gt; o1, Map&lt;String, Object&gt; o2) &#123; String websiteName1 = (String) o1.get("websiteName"); String websiteName2 = (String) o2.get("websiteName"); int io1 = regulationOrder.indexOf(websiteName1); int io2 = regulationOrder.indexOf(websiteName2); return (io1 == -1 || io2 == -1) ? (io2 - io1) : (io1 - io2); &#125; &#125;);&#125; 以上就是经常使用的排序方法。]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一篇迟到的2019年年终总结]]></title>
    <url>%2F2020%2F01%2F30%2F%E8%AE%B0%E4%B8%80%E7%AF%87%E8%BF%9F%E5%88%B0%E7%9A%842019%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前奏： 2019年已经过去，现在才写年终总结似乎有些晚了，之前一直想着在2020年到来之前写，结果由于各种外因导致延迟到现在了，不过该总结的还是要总结，不然对不起过去一年发生的各种故事。 工作： 2019年我是进入新公司的第一年，2018年底由于公司项目发展规划裁员，我在11月底拿了N+1赔偿离开了供职将近2年的公司，其中还是有些舍不得，毕竟是大公司，各种制度毕竟完善，算是我待过的公司综合起来最好的一个了。离开了上家公司，中间就回老家休息了1周就又回来帝都找下家了，这里感谢当时为我推荐工作的各位朋友，虽然最后我选择了我自己找的公司，但是还是谢谢他们，感谢和他们的相遇，期待后续有机会再一起合作。 从老家回到帝都，差不多一周的样子就找好了下家，入职是2018年11月30日，公司算创业公司，搞医药电商的，药兜网，这里给公司打个广告，目前成立4年多，团队规模不算大，产品，技术、测试加起来差不多30个人的样子，但是各个环节都有对应的负责人，还算相对完善团队规模。来到这家公司主要担任后端研发工程师，主要负责公司的B2B产品线的后端开发工作，涉及到得业务主要包括：商品、促销等，日常工作主要是根据产品的需求设计对应的数据结构、开发后端接口，和前端联调接口，修复测试发现的缺陷，协助各组按需求上线功能，其中在做促销这块业务的时候是最忙得时候，还有几次通宵上线的情景，现在想起来，那会儿的忙真的是让自己学到了很多东西，尤其是业务方面和产品迭代流程，包括发布流程，测试流程，上线流程等等。2019年的上半年主要参与了B2B电商平台的后端开发，也是本年度最忙得一个阶段，2019年下半年由于公司产品线的发展，我被抽调到数据组做了一段时间的数据方面的工作，主要包括：数据大屏系统的开发、数据仓库的建设，虽然我们的数据产品只是给公司内部使用，但是在这个过程中，也学到很多东西，比如ElasticSearch、Kettle等，更重要的是学到了一些数据处理方案，比如全量同步数据、增量同步数据、不同环境之间数据同步、百万级别数据同步等方案的落地，这些都让我学到了很多东西，在做完上面那些工作之后，时间已经到2019年10月份了，这个时候，公司又发现了一个新的产品方向，所以就抽调人力成立了一个独立的项目组去做这个项目，也是我2019年年底一直在忙得项目，该项目主要是做医疗行业的舆情和监控，在这个项目组我从原来的后端开发角色增加了一个业务负责人的角色，虽然只是个头衔，但是我还是很看重公司给我的机会的，所以也是在一直边摸索，边实践，虽然在过程中遇到一些问题，但是最后在团队小伙伴的努力下，都一一解决了，最后的成果就是完成了项目的PC版本按时上线，同时在春节前还上线了项目的小程序，这里提一点，上线小程序踩了很多坑，由于之前没有开发过小程序，也没有上线经验，导致最后走了一些弯路，这个后面有时间再详细聊聊，最后总结下，2019年过的还是很充实的，业务上有新的突破，技术上也学到一些新技术，个人发展上也跟上了当时来公司的目标，在做技术的同时，可以学习一下管理，虽然还是个管理菜鸟，但是万事开头难，已经开头了，后面努力坚持，总有突破的一天。 放一张我们一家三口的照片： 生活： 生活方面，2019年也是我人生中最重要的一年，爱人在18年底检查怀孕了，所以整个19年我都是精神状态最紧绷的一年，不但要应对工作中的各种问题，还要照顾怀孕的爱人，虽然我爱人是个比较坚强的女汉子，因为工作的原因，在爱人怀孕整个孕期，我只陪过2次去医院产检，这点我觉得作为男人还是不够的，还好爱人算比较坚强的那类人，没有和我计较，我能做的只有在日后的生活中多多分担生活中的琐事了。2019年08月30日下午16点35迎来了我的小佩奇，从待产到生，我们一起度过了比较难熬的2天，随着小朋友的到来，我感受到了初为人父的喜悦，也心疼爱人从怀孕到生产的辛苦付出，在这里很感谢爱人的付出，期待我们往后余生的精彩生活，也祝福我的小佩奇健康，快乐的成长。 总结： 回想整个2019年，算是我人生中比较重要的一年，经历了工作的变动，也经历了孩子的降生，算是挑战比较多的一年，现在想想有些事只有经历了才会值得回忆，眼下已经是2020年01月30日21点14分，相信大部分人都在家里，因为我们遇到了肺炎病毒，尤其是武汉的同胞们更是处在离病毒最近的地方，在这里盼望病毒早日远离我们，也为武汉加油。]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu Installed Jdk、Tomcat、Nginx、Redis、Zookeeper、Elasticsearch]]></title>
    <url>%2F2019%2F10%2F10%2FUbuntu-Installed-Jdk%E3%80%81Tomcat%E3%80%81Nginx%E3%80%81Redis%E3%80%81Zookeeper%E3%80%81Elasticsearch%2F</url>
    <content type="text"><![CDATA[Ubuntu1.jdk 1.8 安装安装目录：/usr/local/software/ jdk-8u161-linux-x64.tar.gz tar -zxvf jdk-8u161-linux-x64.tar.gz vi /etc/profile export JAVA_HOME=/usr/local/software/jdk1.8.0_161 export CLASSPATH=$:CLASSPATH:$JAVA_HOME/lib/ export PATH=$PATH:$JAVA_HOME/bin source /etc/profile java -version 【JDK】Ubuntu 程序“java”已包含在下列软件包中 解决方法：(手动设置系统默认JDK) 在终端中依次输入命令： sudo update-alternatives –install /usr/bin/java java /usr/local/software/jdk1.8.0_161/bin/java 300 sudo update-alternatives –install /usr/bin/javac javac /usr/local/software/jdk1.8.0_161/bin/javac 300 2.tomcat 8.x 安装tar -zxvf apache-tomcat-8.5.24.tar.gz 3.nginx 安装安装gcc g++的依赖库 apt-get install build-essential apt-get install libtool 安装 pcre依赖库 sudo apt-get update sudo apt-get install libpcre3 libpcre3-dev 安装 ssl依赖库 apt-get install openssl 安装Nginx#下载最新版本：wget http://nginx.org/download/nginx-1.11.3.tar.gz#解压：tar -zxvf nginx-1.11.3.tar.gz#进入解压目录：cd nginx-1.11.3#配置：./configure –prefix=/usr/local/nginx#编辑nginx：make注意：这里可能会报错，提示“pcre.h No such file or directory”,具体详见：http://stackoverflow.com/questions/22555561/error-building-fatal-error-pcre-h-no-such-file-or-directory需要安装 libpcre3-dev,命令为：sudo apt-get install libpcre3-dev#安装nginx：sudo make install#启动nginx：sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf注意：-c 指定配置文件的路径，不加的话，nginx会自动加载默认路径的配置文件，可以通过 -h查看帮助命令。#查看nginx进程：ps -ef|grep nginx 启动 Nginx cd /usr/local/nginx/sbin/nginx ./sbin/nginx 停止 Nginx 停止 Nginx ./sbin/nginx -s stop ./sbin/nginx -s quit -s都是采用向 Nginx 发送信号的方式 Nginx重新加载配置 ./sbin/nginx -s reload 指定配置文件 ./sbin/nginx -c /usr/local/nginx/conf/nginx.conf -c表示configuration，指定配置文件 查看 Nginx 版本 有两种可以查看 Nginx 的版本信息的参数。第一种如下： ./sbin/nginx -v 另一种显示的是详细的版本信息：./sbin/nginx -V 检查配置文件是否正确 ./sbin/nginx -t nginx+tomcat负载均衡配置 4.redis安装参考地址：https://blog.csdn.net/qq_30242609/article/details/52913145 安装Redis服务器端sudo apt-get install redis-server 安装完成后，Redis服务器会自动启动，我们检查Redis服务器程序 检查Redis服务器系统进程ps -aux|grep redis返回结果：redis 4162 0.1 0.0 10676 1420 ? Ss 23:24 0:00 /usr/bin/redis-server /etc/redis/redis.confconan 4172 0.0 0.0 11064 924 pts/0 S+ 23:26 0:00 grep –color=auto redis 通过启动命令检查Redis服务器状态netstat -nlt|grep 6379返回结果：tcp 0 0 127.0.0.1:6379 0.0.0.0:* LISTEN 通过启动命令检查Redis服务器状态sudo /etc/init.d/redis-server status返回结果：redis-server is running 通过命令行客户端访问Redis安装Redis服务器，会自动地一起安装Redis命令行客户端程序。 在本机输入redis-cli命令就可以启动，客户端程序访问Redis服务器。 redis-cliredis 127.0.0.1:6379&gt; #命令行的帮助 redis 127.0.0.1:6379&gt; helpredis-cli 2.2.12Type: “help @” to get a list of commands in “help “ for help on “help “ to get a list of possible help topics “quit” to exit #查看所有的key列表 redis 127.0.0.1:6379&gt; keys *(empty list or set) 修改Redis的配置 使用Redis的访问账号默认情况下，访问Redis服务器是不需要密码的，为了增加安全性我们需要设置Redis服务器的访问密码。设置访问密码为redisredis。 用vi打开Redis服务器的配置文件redis.confsudo vi /etc/redis/redis.conf #取消注释requirepassrequirepass redisredis 让Redis服务器被远程访问 默认情况下，Redis服务器不允许远程访问，只允许本机访问，所以我们需要设置打开远程访问的功能。 用vi打开Redis服务器的配置文件redis.conf sudo vi /etc/redis/redis.conf #注释bind#bind 127.0.0.1 修改后，重启Redis服务器sudo /etc/init.d/redis-server restart 未使用密码登陆Redis服务器redis-cli redis 127.0.0.1:6379&gt; keys *(error) ERR operation not permitted 发现可以登陆，但无法执行命令了。 登陆Redis服务器，输入密码 redis-cli -a redisredis redis 127.0.0.1:6379&gt; keys * 1) “key2”2) “key3”3) “key4” 登陆后，一切正常。 我们检查Redis的网络监听端口 检查Redis服务器占用端口netstat -nlt|grep 6379tcp 0 0 0.0.0.0:6379 0.0.0.0:* LISTEN 5.zookeeper安装下载zookeeper-3.4.5版本的安装包 解压zookeeper到/usr/local tar -xzvf zookeeper-3.4.5.tar.gz -C /usr/local cd /usr/local/zookeeper-3.4.5 拷贝一份zookeeper的配置文件，zoo_sample.cfg =&gt; zoo.cfg cd conf cp zoo_sample.cfg zoo.cfg 变更zoo.cfg配置 vi zoo.cfg 主要更改zookeeper的数据存放地址和日志地址 dataDir=/HD/logs/zookeeper dataLogDir=/HD/logs/zookeeper 启动zookeeper cd ../bin sh zkServer.sh start //启动 sh zkServer.sh status //检查状态 sh zkServer.sh stop //停止]]></content>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch Getting Started (三)]]></title>
    <url>%2F2019%2F10%2F06%2F%E7%AD%89%E5%BE%85%2F</url>
    <content type="text"><![CDATA[一：Introduction 二：Description 三：Summary]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch Getting Started (二）]]></title>
    <url>%2F2019%2F10%2F06%2FElasticsearch-Getting-Started-%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一：Introduction 二：Description 三：Summary]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch Getting Started (一）]]></title>
    <url>%2F2019%2F10%2F06%2FElasticsearch-Getting-Started-%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一：Introduction 二：Description 三：Summary]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Wedding Photo]]></title>
    <url>%2F2019%2F10%2F06%2FMy%20Wedding%20Photo%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
